
// Generated by peggy v. 3.0.2 (ts-pegjs plugin v. 3.1.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs

"use strict";

export interface FilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface FileRange {
  start: FilePosition;
  end: FilePosition;
  source: string;
}

export interface LiteralExpectation {
  type: "literal";
  text: string;
  ignoreCase: boolean;
}

export interface ClassParts extends Array<string | ClassParts> {}

export interface ClassExpectation {
  type: "class";
  parts: ClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface AnyExpectation {
  type: "any";
}

export interface EndExpectation {
  type: "end";
}

export interface OtherExpectation {
  type: "other";
  description: string;
}

export type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;

function peg$padEnd(str: string, targetLength: number, padString: string) {
  padString = padString || ' ';
  if (str.length > targetLength) {
    return str;
  }
  targetLength -= str.length;
  padString += padString.repeat(targetLength);
  return str + padString.slice(0, targetLength);
}

export class PeggySyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null) {
    function hex(ch: string): string {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/"/g,  "\\\"")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function classEscape(s: string): string {
      return s
        .replace(/\\/g, "\\\\")
        .replace(/\]/g, "\\]")
        .replace(/\^/g, "\\^")
        .replace(/-/g,  "\\-")
        .replace(/\0/g, "\\0")
        .replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/[\x00-\x0F]/g,            (ch) => "\\x0" + hex(ch) )
        .replace(/[\x10-\x1F\x7F-\x9F]/g, (ch) => "\\x"  + hex(ch) );
    }

    function describeExpectation(expectation: Expectation) {
      switch (expectation.type) {
        case "literal":
          return "\"" + literalEscape(expectation.text) + "\"";
        case "class":
          const escapedParts = expectation.parts.map((part) => {
            return Array.isArray(part)
              ? classEscape(part[0] as string) + "-" + classEscape(part[1] as string)
              : classEscape(part);
          });

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }

    function describeExpected(expected1: Expectation[]) {
      const descriptions = expected1.map(describeExpectation);
      let i: number;
      let j: number;

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found1: string | null) {
      return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  }

  public message: string;
  public expected: Expectation[];
  public found: string | null;
  public location: FileRange;
  public name: string;

  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange) {
    super();
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "PeggySyntaxError";

    if (typeof (Object as any).setPrototypeOf === "function") {
      (Object as any).setPrototypeOf(this, PeggySyntaxError.prototype);
    } else {
      (this as any).__proto__ = PeggySyntaxError.prototype;
    }
    if (typeof (Error as any).captureStackTrace === "function") {
      (Error as any).captureStackTrace(this, PeggySyntaxError);
    }
  }

  format(sources: { grammarSource?: string; text: string }[]): string {
    let str = 'Error: ' + this.message;
    if (this.location) {
      let src: string[] | null = null;
      let k;
      for (k = 0; k < sources.length; k++) {
        if (sources[k].grammarSource === this.location.source) {
          src = sources[k].text.split(/\r\n|\n|\r/g);
          break;
        }
      }
      let s = this.location.start;
      let loc = this.location.source + ':' + s.line + ':' + s.column;
      if (src) {
        let e = this.location.end;
        let filler = peg$padEnd('', s.line.toString().length, ' ');
        let line = src[s.line - 1];
        let last = s.line === e.line ? e.column : line.length + 1;
        str += '\n --> ' + loc + '\n' + filler + ' |\n' + s.line + ' | ' + line + '\n' + filler + ' | ' +
          peg$padEnd('', s.column - 1, ' ') +
          peg$padEnd('', last - s.column, '^');
      } else {
        str += '\n at ' + loc;
      }
    }
    return str;
  }
}

function peg$parse(input: string, options?: ParseOptions) {
  options = options !== undefined ? options : {};

  const peg$FAILED: Readonly<any> = {};
  const peg$source = options.grammarSource;

  const peg$startRuleFunctions: {[id: string]: any} = { start: peg$parsestart };
  let peg$startRuleFunction: () => any = peg$parsestart;

  const peg$c0 = function(s: any): any {
      return s;
    };
  const peg$c1 = function(f: any, b: any): any {
      return {
        'type': 'statement',
        'variant': 'list',
        'statement': flattenAll([ f, b ])
      };
    };
  const peg$c2 = function(s: any): any { return s; };
  const peg$c3 = peg$otherExpectation("Type Definition");
  const peg$c4 = function(t: any, a: any): any {
      return Object.assign(t, a);
    };
  const peg$c5 = function(n: any): any {
      return {
        'type': 'datatype',
        'variant': n[0],
        'affinity': n[1]
      };
    };
  const peg$c6 = peg$otherExpectation("Custom Datatype Name");
  const peg$c7 = function(t: any, r: any): any {
      const variant = foldStringKey([ t, r ]);
      let affinity = 'numeric';
      if (/int/i.test(variant)) {
        affinity = 'integer';
      } else if (/char|clob|text/i.test(variant)) {
        affinity = 'text';
      } else if (/blob/i.test(variant)) {
        affinity = 'blob';
      } else if (/real|floa|doub/i.test(variant)) {
        affinity = 'real';
      }
      return {
        'type': 'datatype',
        'variant': variant,
        'affinity': affinity
      };
    };
  const peg$c8 = /^[\t ]/;
  const peg$c9 = peg$classExpectation(["\t", " "], false, false);
  const peg$c10 = function(w: any): any {
      return w;
    };
  const peg$c11 = peg$otherExpectation("Type Definition Arguments");
  const peg$c12 = function(a1: any, a2: any): any {
      return {
        'args': {
          'type': 'expression',
          'variant': 'list',
          'expression': flattenAll([ a1, a2 ])
        }
      };
    };
  const peg$c13 = function(n: any): any { return n; };
  const peg$c14 = peg$otherExpectation("Null Literal");
  const peg$c15 = function(n: any): any {
      return {
        'type': 'literal',
        'variant': 'null',
        'value': keyNode(n)
      };
    };
  const peg$c16 = peg$otherExpectation("Date Literal");
  const peg$c17 = function(d: any): any {
      return {
        'type': 'literal',
        'variant': 'date',
        'value': keyNode(d)
      };
    };
  const peg$c18 = peg$otherExpectation("String Literal");
  const peg$c19 = function(n: any, s: any): any {
      return {
        'type': 'literal',
        'variant': 'text',
        'value': s
      };
    };
  const peg$c20 = peg$otherExpectation("Single-quoted String Literal");
  const peg$c21 = function(s: any): any {
      /**
       * @note Unescaped the pairs of literal single quotation marks
       */
      /**
       * @note Not sure if the BLOB type should be un-escaped
       */
      return unescape(s, "'");
    };
  const peg$c22 = "''";
  const peg$c23 = peg$literalExpectation("''", false);
  const peg$c24 = /^[^']/;
  const peg$c25 = peg$classExpectation(["'"], true, false);
  const peg$c26 = peg$otherExpectation("Blob Literal");
  const peg$c27 = /^[x]/i;
  const peg$c28 = peg$classExpectation(["x"], false, true);
  const peg$c29 = function(b: any): any {
      return {
        'type': 'literal',
        'variant': 'blob',
        'value': b
      };
    };
  const peg$c30 = function(n: any): any {
      return {
        'type': 'literal',
        'variant': 'text',
        'value': n
      };
    };
  const peg$c31 = peg$otherExpectation("Number Sign");
  const peg$c32 = function(s: any, n: any): any {
      if (isOkay(s)) {
        n['value'] = foldStringWord([ s, n['value'] ]);
      }
      return n;
    };
  const peg$c33 = function(d: any, e: any): any {
      return {
        'type': 'literal',
        'variant': 'decimal',
        'value': foldStringWord([ d, e ])
      };
    };
  const peg$c34 = peg$otherExpectation("Decimal Literal");
  const peg$c35 = function(f: any, b: any): any { return foldStringWord([ f, b ]); };
  const peg$c36 = function(t: any, d: any): any { return foldStringWord([ t, d ]); };
  const peg$c37 = peg$otherExpectation("Decimal Literal Exponent");
  const peg$c38 = "e";
  const peg$c39 = peg$literalExpectation("E", true);
  const peg$c40 = /^[+\-]/;
  const peg$c41 = peg$classExpectation(["+", "-"], false, false);
  const peg$c42 = function(e: any, s: any, d: any): any { return foldStringWord([ e, s, d ]); };
  const peg$c43 = peg$otherExpectation("Hexidecimal Literal");
  const peg$c44 = "0x";
  const peg$c45 = peg$literalExpectation("0x", true);
  const peg$c46 = function(f: any, b: any): any {
      return {
        'type': 'literal',
        'variant': 'hexidecimal',
        'value': foldStringWord([ f, b ])
      };
    };
  const peg$c47 = /^[0-9a-f]/i;
  const peg$c48 = peg$classExpectation([["0", "9"], ["a", "f"]], false, true);
  const peg$c49 = /^[0-9]/;
  const peg$c50 = peg$classExpectation([["0", "9"]], false, false);
  const peg$c51 = peg$otherExpectation("Bind Parameter");
  const peg$c52 = function(b: any): any {
      return Object.assign({
        'type': 'variable'
      }, b);
    };
  const peg$c53 = peg$otherExpectation("Numbered Bind Parameter");
  const peg$c54 = function(q: any, id: any): any {
      return {
        'format': 'numbered',
        'name': foldStringWord([ q, id ])
      };
    };
  const peg$c55 = /^[1-9]/;
  const peg$c56 = peg$classExpectation([["1", "9"]], false, false);
  const peg$c57 = function(f: any, r: any): any {
      return foldStringWord([ f, r ]);
    };
  const peg$c58 = peg$otherExpectation("Named Bind Parameter");
  const peg$c59 = /^[:@]/;
  const peg$c60 = peg$classExpectation([":", "@"], false, false);
  const peg$c61 = function(s: any, name: any): any {
      return {
        'format': 'named',
        'name': foldStringWord([ s, name ])
      };
    };
  const peg$c62 = peg$otherExpectation("TCL Bind Parameter");
  const peg$c63 = "$";
  const peg$c64 = peg$literalExpectation("$", false);
  const peg$c65 = ":";
  const peg$c66 = peg$literalExpectation(":", false);
  const peg$c67 = function(d: any, name: any, s: any): any {
      return Object.assign({
        'format': 'tcl',
        'name': foldStringWord([ d, name ])
      }, s);
    };
  const peg$c68 = function(sfx: any): any {
      return {
        'suffix': sfx
      };
    };
  const peg$c69 = peg$otherExpectation("EXISTS Expression");
  const peg$c70 = function(n: any, e: any): any {
      if (isOkay(n)) {
        return {
          'type': 'expression',
          'format': 'unary',
          'variant': 'exists',
          'expression': e,
          'operator': keyNode(n)
        };
      }
      return e;
    };
  const peg$c71 = peg$otherExpectation("EXISTS Keyword");
  const peg$c72 = function(n: any, x: any): any { return foldStringKey([ n, x ]); };
  const peg$c73 = peg$otherExpectation("RAISE Expression");
  const peg$c74 = function(s: any, a: any): any {
      return Object.assign({
        'type': 'expression',
        'format': 'unary',
        'variant': keyNode(s),
        'expression': a
      }, a);
    };
  const peg$c75 = peg$otherExpectation("RAISE Expression Arguments");
  const peg$c76 = function(a: any): any {
      return Object.assign({
        'type': 'error'
      }, a);
    };
  const peg$c77 = peg$otherExpectation("IGNORE Keyword");
  const peg$c78 = function(f: any): any {
      return {
        'action': keyNode(f)
      };
    };
  const peg$c79 = function(f: any, m: any): any {
      return {
        'action': keyNode(f),
        'message': m
      };
    };
  const peg$c80 = function(n: any): any {
      return n;
    };
  const peg$c81 = function(e: any, c: any): any {
      return Object.assign(c, {
        'expression': e
      });
    };
  const peg$c82 = function(op: any, e: any): any {
      return {
        'type': 'expression',
        'format': 'unary',
        'variant': 'operation',
        'expression': e,
        'operator': keyNode(op)
      };
    };
  const peg$c83 = peg$otherExpectation("COLLATE Expression");
  const peg$c84 = function(c: any): any {
      return Object.assign({
        'type': 'expression',
        'format': 'unary',
        'variant': 'operation',
        'operator': 'collate'
      }, c);
    };
  const peg$c85 = function(f: any, rest: any): any { return composeBinary(f, rest); };
  const peg$c86 = function(i: any): any {
      return [null, i, null, {
        'type': 'literal',
        'variant': 'null',
        'value': 'null'
      }];
    };
  const peg$c87 = "not ";
  const peg$c88 = peg$literalExpectation("NOT ", true);
  const peg$c89 = "null";
  const peg$c90 = peg$literalExpectation("NULL", true);
  const peg$c91 = function(): any { return 'not'; };
  const peg$c92 = function(): any { return 'is'; };
  const peg$c93 = peg$otherExpectation("CAST Expression");
  const peg$c94 = function(s: any, e: any, a: any): any {
      return {
        'type': 'expression',
        'format': 'unary',
        'variant': keyNode(s),
        'expression': e,
        'as': a
      };
    };
  const peg$c95 = peg$otherExpectation("Type Alias");
  const peg$c96 = function(d: any): any { return d; };
  const peg$c97 = peg$otherExpectation("CASE Expression");
  const peg$c98 = function(t: any, e: any, w: any, s: any): any {
      return Object.assign({
        'type': 'expression',
        'variant': keyNode(t),
        'expression': flattenAll([ w, s ])
      }, e);
    };
  const peg$c99 = function(e: any): any {
      return {
        'discriminant': e
      };
    };
  const peg$c100 = peg$otherExpectation("WHEN Clause");
  const peg$c101 = function(s: any, w: any, t: any): any {
      return {
        'type': 'condition',
        'variant': keyNode(s),
        'condition': w,
        'consequent': t
      };
    };
  const peg$c102 = peg$otherExpectation("ELSE Clause");
  const peg$c103 = function(s: any, e: any): any {
      return {
        'type': 'condition',
        'variant': keyNode(s),
        'consequent': e
      };
    };
  const peg$c104 = function(v: any, p: any): any {
      return Object.assign(p, {
        'left': v
      });
    };
  const peg$c105 = peg$otherExpectation("Comparison Expression");
  const peg$c106 = function(n: any, m: any, e: any, x: any): any {
      return Object.assign({
        'type': 'expression',
        'format': 'binary',
        'variant': 'operation',
        'operation': foldStringKey([ n, m ]),
        'right': e
      }, x);
    };
  const peg$c107 = peg$otherExpectation("ESCAPE Expression");
  const peg$c108 = function(s: any, e: any): any {
      return {
        'escape': e
      };
    };
  const peg$c109 = peg$otherExpectation("BETWEEN Expression");
  const peg$c110 = function(n: any, b: any, tail: any): any {
      return {
        'type': 'expression',
        'format': 'binary',
        'variant': 'operation',
        'operation': foldStringKey([ n, b ]),
        'right': tail
      };
    };
  const peg$c111 = function(f: any, rest: any): any { return composeBinary(f, [ rest ]); };
  const peg$c112 = function(n: any): any { return keyNode(n); };
  const peg$c113 = peg$otherExpectation("IN Expression");
  const peg$c114 = function(n: any, i: any, e: any): any {
      return {
        'type': 'expression',
        'format': 'binary',
        'variant': 'operation',
        'operation': foldStringKey([ n, i ]),
        'right': e
      };
    };
  const peg$c115 = function(e: any): any { return e; };
  const peg$c116 = peg$otherExpectation("Expression List");
  const peg$c117 = function(l: any): any {
      return {
        'type': 'expression',
        'variant': 'list',
        'expression': isOkay(l) ? l : []
      };
    };
  const peg$c118 = function(f: any, rest: any): any {
      return flattenAll([ f, rest ]);
    };
  const peg$c119 = peg$otherExpectation("Function Call");
  const peg$c120 = function(n: any, a: any): any {
      return Object.assign({
        'type': 'function',
        'name': n
      }, a);
    };
  const peg$c121 = peg$otherExpectation("Function Call Arguments");
  const peg$c122 = function(s: any): any {
      return {
        'args': {
          'type': 'identifier',
          'variant': 'star',
          'name': s
        }
      };
    };
  const peg$c123 = function(d: any, e: any): any {
      return !isOkay(d) || e['expression'].length > 0;
    };
  const peg$c124 = function(d: any, e: any): any {
      return {
        'args': Object.assign(e, d)
      };
    };
  const peg$c125 = function(s: any): any {
      return {
        'filter': keyNode(s)
      };
    };
  const peg$c126 = peg$otherExpectation("Error Message");
  const peg$c127 = function(m: any): any { return m; };
  const peg$c128 = peg$otherExpectation("Statement");
  const peg$c129 = function(m: any, s: any): any {
      return Object.assign(s, m);
    };
  const peg$c130 = peg$otherExpectation("QUERY PLAN");
  const peg$c131 = function(e: any, q: any): any {
      return {
        'explain': isOkay(e)
      };
    };
  const peg$c132 = peg$otherExpectation("QUERY PLAN Keyword");
  const peg$c133 = function(q: any, p: any): any { return foldStringKey([ q, p ]); };
  const peg$c134 = peg$otherExpectation("END Transaction Statement");
  const peg$c135 = function(s: any, t: any): any {
      return {
        'type': 'statement',
        'variant': 'transaction',
        'action': 'commit'
      };
    };
  const peg$c136 = peg$otherExpectation("BEGIN Transaction Statement");
  const peg$c137 = function(s: any, m: any, t: any, n: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': 'transaction',
        'action': 'begin'
      }, m, n);
    };
  const peg$c138 = function(t: any): any { return t; };
  const peg$c139 = function(m: any): any {
      return {
        'defer': keyNode(m)
      };
    };
  const peg$c140 = peg$otherExpectation("ROLLBACK Statement");
  const peg$c141 = function(s: any, n: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': 'transaction',
        'action': 'rollback'
      }, n);
    };
  const peg$c142 = peg$otherExpectation("TO Clause");
  const peg$c143 = function(n: any): any {
      return {
        'savepoint': n
      }
    };
  const peg$c144 = function(s: any): any { return keyNode(s); };
  const peg$c145 = peg$otherExpectation("SAVEPOINT Statement");
  const peg$c146 = function(s: any, n: any): any {
      return {
        'type': 'statement',
        'variant': s,
        'target': n
      };
    };
  const peg$c147 = peg$otherExpectation("RELEASE Statement");
  const peg$c148 = function(s: any, a: any, n: any): any {
      return {
        'type': 'statement',
        'variant': keyNode(s),
        'target': n
      };
    };
  const peg$c149 = peg$otherExpectation("ALTER TABLE Statement");
  const peg$c150 = function(s: any, n: any, e: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': keyNode(s),
        'target': n
      }, e);
    };
  const peg$c151 = peg$otherExpectation("ALTER TABLE Keyword");
  const peg$c152 = function(a: any, t: any): any { return foldStringKey([ a, t ]); };
  const peg$c153 = peg$otherExpectation("RENAME TO Keyword");
  const peg$c154 = function(s: any, n: any): any {
      return {
        'action': keyNode(s),
        'name': n
      };
    };
  const peg$c155 = peg$otherExpectation("ADD COLUMN Keyword");
  const peg$c156 = function(s: any, d: any): any {
      return {
        'action': keyNode(s),
        'definition': d
      };
    };
  const peg$c157 = function(w: any, s: any): any { return Object.assign(s, w); };
  const peg$c158 = peg$otherExpectation("WITH Clause");
  const peg$c159 = function(s: any, v: any, t: any): any {
      var recursive = {
        'variant': isOkay(v) ? 'recursive' : 'common'
      };
      if (isArrayOkay(t)) {
        // Add 'recursive' property into each table expression
        t = t.map(function (elem) {
          return Object.assign(elem, recursive);
        });
      }
      return {
        'with': t
      };
    };
  const peg$c160 = function(f: any, r: any): any { return flattenAll([ f, r ]); };
  const peg$c161 = peg$otherExpectation("Common Table Expression");
  const peg$c162 = function(t: any, s: any): any {
      return Object.assign({
        'type': 'expression',
        'format': 'table',
        'variant': 'common',
        'target': t
      }, s);
    };
  const peg$c163 = function(s: any): any {
      return {
        'expression': s
      };
    };
  const peg$c164 = function(w: any, s: any): any {
      return Object.assign(s, w);
    };
  const peg$c165 = peg$otherExpectation("ATTACH Statement");
  const peg$c166 = function(a: any, b: any, e: any, n: any): any {
      return {
        'type': 'statement',
        'variant': keyNode(a),
        'target': n,
        'attach': e
      };
    };
  const peg$c167 = peg$otherExpectation("DETACH Statement");
  const peg$c168 = function(d: any, b: any, n: any): any {
      return {
        'type': 'statement',
        'variant': keyNode(d),
        'target': n
      };
    };
  const peg$c169 = peg$otherExpectation("VACUUM Statement");
  const peg$c170 = function(v: any, t: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': 'vacuum'
      }, t);
    };
  const peg$c171 = function(t: any): any {
      return {
        'target': t
      };
    };
  const peg$c172 = peg$otherExpectation("ANALYZE Statement");
  const peg$c173 = function(s: any, a: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': keyNode(s)
      }, a);
    };
  const peg$c174 = function(n: any): any {
      return {
        'target': n['name']
      };
    };
  const peg$c175 = peg$otherExpectation("REINDEX Statement");
  const peg$c176 = function(a: any): any {
      return {
        'target': a['name']
      };
    };
  const peg$c177 = peg$otherExpectation("PRAGMA Statement");
  const peg$c178 = function(s: any, n: any, v: any): any {
      return {
        'type': 'statement',
        'variant': keyNode(s),
        'target': n,
        'args': {
          'type': 'expression',
          'variant': 'list',
          'expression': v
        }
      };
    };
  const peg$c179 = function(v: any): any { return v; };
  const peg$c180 = function(v: any): any { return /^(yes|no|on|off|false|true|0|1)$/i.test(v) };
  const peg$c181 = function(v: any): any {
      return {
        'type': 'literal',
        'variant': 'boolean',
        'normalized': (/^(yes|on|true|1)$/i.test(v) ? '1' : '0'),
        'value': v
      };
    };
  const peg$c182 = function(n: any): any {
      return keyNode(n);
    };
  const peg$c183 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'name',
        'name': n
      };
    };
  const peg$c184 = peg$otherExpectation("SELECT Statement");
  const peg$c185 = function(s: any, o: any, l: any): any {
      return Object.assign(s, o, l);
    };
  const peg$c186 = peg$otherExpectation("ORDER BY Clause");
  const peg$c187 = function(d: any): any {
      return {
        'order': d['result']
      };
    };
  const peg$c188 = peg$otherExpectation("LIMIT Clause");
  const peg$c189 = function(s: any, e: any, d: any): any {
      return {
        'limit': Object.assign({
          'type': 'expression',
          'variant': 'limit',
          'start': e
        }, d)
      };
    };
  const peg$c190 = peg$otherExpectation("OFFSET Clause");
  const peg$c191 = function(o: any, e: any): any {
      return {
        'offset': e
      };
    };
  const peg$c192 = function(s: any, u: any): any {
      if (isArrayOkay(u)) {
        return {
          'type': 'statement',
          'variant': 'compound',
          'statement': s,
          'compound': u
        };
      } else {
        return s;
      }
    };
  const peg$c193 = peg$otherExpectation("Union Operation");
  const peg$c194 = function(c: any, s: any): any {
      return {
        'type': 'compound',
        'variant': c,
        'statement': s
      };
    };
  const peg$c195 = function(s: any, f: any, w: any, g: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': 'select',
      }, s, f, w, g);
    };
  const peg$c196 = peg$otherExpectation("SELECT Results Clause");
  const peg$c197 = function(d: any, t: any): any {
      return Object.assign({
        'result': t
      }, d);
    };
  const peg$c198 = peg$otherExpectation("SELECT Results Modifier");
  const peg$c199 = function(s: any): any {
      return {
        'distinct': true
      };
    };
  const peg$c200 = function(s: any): any {
      return {};
    };
  const peg$c201 = peg$otherExpectation("FROM Clause");
  const peg$c202 = function(f: any, s: any): any {
      return {
        'from': s
      };
    };
  const peg$c203 = peg$otherExpectation("WHERE Clause");
  const peg$c204 = function(f: any, e: any): any {
      return {
        'where': makeArray(e)
      };
    };
  const peg$c205 = peg$otherExpectation("GROUP BY Clause");
  const peg$c206 = function(f: any, e: any, h: any): any {
      return Object.assign({
        'group': e
      }, h);
    };
  const peg$c207 = peg$otherExpectation("HAVING Clause");
  const peg$c208 = function(f: any, e: any): any {
      return {
        'having': e
      };
    };
  const peg$c209 = function(q: any, s: any): any {
      return {
        'type': 'identifier',
        'variant': 'star',
        'name': foldStringWord([ q, s ])
      };
    };
  const peg$c210 = function(n: any, s: any): any { return foldStringWord([ n, s ]); };
  const peg$c211 = function(e: any, a: any): any {
      return Object.assign(e, a);
    };
  const peg$c212 = function(f: any, t: any): any {
      if (isArrayOkay(t)) {
        return {
          'type': 'map',
          'variant': 'join',
          'source': f,
          'map': t
        };
      }
      return f;
    };
  const peg$c213 = function(cl: any, c: any): any {
      return Object.assign(cl, c);
    };
  const peg$c214 = peg$otherExpectation("CROSS JOIN Operation");
  const peg$c215 = function(n: any): any {
      return {
        'type': 'join',
        'variant': 'cross join',
        'source': n
      };
    };
  const peg$c216 = peg$otherExpectation("JOIN Operation");
  const peg$c217 = function(o: any, n: any): any {
      return {
        'type': 'join',
        'variant': keyNode(o),
        'source': n
      };
    };
  const peg$c218 = function(n: any, l: any, a: any): any {
      return Object.assign({
        'type': 'function',
        'variant': 'table',
        'name': n,
        'args': l
      }, a);
    };
  const peg$c219 = peg$otherExpectation("Qualified Table");
  const peg$c220 = function(d: any, i: any): any {
      return Object.assign(d, i);
    };
  const peg$c221 = peg$otherExpectation("Qualified Table Identifier");
  const peg$c222 = function(n: any, a: any): any {
      return Object.assign(n, a);
    };
  const peg$c223 = peg$otherExpectation("Qualfied Table Index");
  const peg$c224 = function(s: any, n: any): any {
      return {
        'index': n
      };
    };
  const peg$c225 = function(n: any, i: any): any {
      // TODO: Not sure what should happen here
      return {
        'index': foldStringKey([ n, i ])
      };
    };
  const peg$c226 = peg$otherExpectation("SELECT Source");
  const peg$c227 = function(l: any, a: any): any { return Object.assign(l, a); };
  const peg$c228 = peg$otherExpectation("Subquery");
  const peg$c229 = function(s: any, a: any): any {
      return Object.assign(s, a);
    };
  const peg$c230 = peg$otherExpectation("Alias");
  const peg$c231 = function(a: any, n: any): any {
      return {
        'alias': n
      };
    };
  const peg$c232 = peg$otherExpectation("JOIN Operator");
  const peg$c233 = function(n: any, t: any, j: any): any { return foldStringKey([ n, t, j ]); };
  const peg$c234 = function(t: any, o: any): any { return foldStringKey([ t, o ]); };
  const peg$c235 = function(t: any): any { return keyNode(t); };
  const peg$c236 = peg$otherExpectation("JOIN Constraint");
  const peg$c237 = function(c: any): any {
      return {
        'constraint': Object.assign({
          'type': 'constraint',
          'variant': 'join'
        }, c)
      }
    };
  const peg$c238 = peg$otherExpectation("Join ON Clause");
  const peg$c239 = function(s: any, e: any): any {
      return {
        'format': keyNode(s),
        'on': e
      };
    };
  const peg$c240 = peg$otherExpectation("Join USING Clause");
  const peg$c241 = function(s: any, e: any): any {
      return {
        'format': keyNode(s),
        'using': e
      };
    };
  const peg$c242 = peg$otherExpectation("VALUES Clause");
  const peg$c243 = function(s: any, l: any): any {
      return {
        'type': 'statement',
        'variant': 'select',
        'result': l
      };
    };
  const peg$c244 = function(f: any, b: any): any {
      return {
        'result': flattenAll([ f, b ])
      };
    };
  const peg$c245 = function(i: any): any { return i; };
  const peg$c246 = peg$otherExpectation("Ordering Expression");
  const peg$c247 = function(e: any, d: any): any {
      // Only convert this into an ordering expression if it contains
      // more than just the expression.
      if (isOkay(d)) {
        return Object.assign({
          'type': 'expression',
          'variant': 'order',
          'expression': e
        }, d);
      }
      return e;
    };
  const peg$c248 = peg$otherExpectation("Star");
  const peg$c249 = peg$otherExpectation("Fallback Type");
  const peg$c250 = peg$otherExpectation("INSERT Statement");
  const peg$c251 = function(k: any, t: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': 'insert'
      }, k, t);
    };
  const peg$c252 = peg$otherExpectation("INSERT Keyword");
  const peg$c253 = function(a: any, m: any): any {
      return Object.assign({
        'action': keyNode(a)
      }, m);
    };
  const peg$c254 = peg$otherExpectation("REPLACE Keyword");
  const peg$c255 = function(a: any): any {
      return {
        'action': keyNode(a)
      };
    };
  const peg$c256 = peg$otherExpectation("INSERT OR Modifier");
  const peg$c257 = function(s: any, m: any): any {
      return {
        'or': keyNode(m)
      };
    };
  const peg$c258 = function(i: any, r: any): any {
      return Object.assign({
        'into': i
      }, r);
    };
  const peg$c259 = peg$otherExpectation("INTO Clause");
  const peg$c260 = function(s: any, t: any): any {
      return t;
    };
  const peg$c261 = peg$otherExpectation("INTO Keyword");
  const peg$c262 = function(r: any): any {
      return {
        'result': r
      };
    };
  const peg$c263 = peg$otherExpectation("Column List");
  const peg$c264 = function(f: any, b: any): any {
      return {
        'columns': flattenAll([ f, b ])
      };
    };
  const peg$c265 = function(c: any): any { return c; };
  const peg$c266 = peg$otherExpectation("Column Name");
  const peg$c267 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'column',
        'name': n
      };
    };
  const peg$c268 = function(s: any, r: any): any { return r; };
  const peg$c269 = peg$otherExpectation("VALUES Keyword");
  const peg$c270 = function(f: any, b: any): any { return flattenAll([ f, b ]); };
  const peg$c271 = peg$otherExpectation("Wrapped Expression List");
  const peg$c272 = function(e: any): any {
      return e;
    };
  const peg$c273 = peg$otherExpectation("DEFAULT VALUES Clause");
  const peg$c274 = function(d: any, v: any): any {
      return {
        'type': 'values',
        'variant': 'default'
        // TODO: Not sure what should go here
        // , 'values': null
      };
    };
  const peg$c275 = peg$otherExpectation("Compound Operator");
  const peg$c276 = peg$otherExpectation("UNION Operator");
  const peg$c277 = function(s: any, a: any): any { return foldStringKey([ s, a ]); };
  const peg$c278 = function(a: any): any { return a; };
  const peg$c279 = peg$otherExpectation("UPDATE Statement");
  const peg$c280 = function(s: any, f: any, t: any, u: any, w: any, o: any, l: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': s,
        'into': t
      }, f, u, w, o, l);
    };
  const peg$c281 = peg$otherExpectation("UPDATE Keyword");
  const peg$c282 = peg$otherExpectation("UPDATE OR Modifier");
  const peg$c283 = function(t: any): any {
      return {
        'or': keyNode(t)
      };
    };
  const peg$c284 = peg$otherExpectation("SET Clause");
  const peg$c285 = function(c: any): any {
      return {
        'set': c
      };
    };
  const peg$c286 = peg$otherExpectation("Column Assignment");
  const peg$c287 = function(f: any, e: any): any {
      return {
        'type': 'assignment',
        'target': f,
        'value': e
      };
    };
  const peg$c288 = peg$otherExpectation("DELETE Statement");
  const peg$c289 = function(s: any, t: any, w: any, o: any, l: any): any {
      return Object.assign({
        'type': 'statement',
        'variant': s,
        'from': t
      }, w, o, l);
    };
  const peg$c290 = peg$otherExpectation("DELETE Keyword");
  const peg$c291 = peg$otherExpectation("CREATE Statement");
  const peg$c292 = peg$otherExpectation("CREATE TABLE Statement");
  const peg$c293 = function(s: any, ne: any, id: any, r: any): any {
      return Object.assign({
        'type': 'statement',
        'name': id
      }, s, r, ne);
    };
  const peg$c294 = function(s: any, tmp: any, t: any): any {
      return Object.assign({
        'variant': s,
        'format': keyNode(t)
      }, tmp);
    };
  const peg$c295 = function(t: any): any {
      return {
        'temporary': isOkay(t)
      };
    };
  const peg$c296 = peg$otherExpectation("IF NOT EXISTS Modifier");
  const peg$c297 = function(i: any, n: any, e: any): any {
      return {
        'condition': makeArray({
          'type': 'condition',
          'variant': keyNode(i),
          'condition': {
            'type': 'expression',
            'variant': keyNode(e),
            'operator': foldStringKey([ n, e ])
          }
        })
      };
    };
  const peg$c298 = peg$otherExpectation("Table Definition");
  const peg$c299 = function(s: any, t: any, r: any): any {
      return Object.assign({
        'definition': flattenAll([ s, t ])
      }, r);
    };
  const peg$c300 = function(r: any, w: any): any {
      return {
        'optimization': [{
          'type': 'optimization',
          'value': foldStringKey([ r, w ])
        }]
      };
    };
  const peg$c301 = function(f: any): any { return f; };
  const peg$c302 = peg$otherExpectation("Column Definition");
  const peg$c303 = function(n: any, t: any, c: any): any {
      return Object.assign({
        'type': 'definition',
        'variant': 'column',
        'name': n,
        'definition': (isOkay(c) ? c : []),
      }, t);
    };
  const peg$c304 = peg$otherExpectation("Column Datatype");
  const peg$c305 = function(t: any): any {
      return {
        'datatype': t
      };
    };
  const peg$c306 = peg$otherExpectation("Column Constraint");
  const peg$c307 = function(n: any, c: any, ln: any): any {
      return Object.assign(c, n);
    };
  const peg$c308 = function(cl: any): any {
      return cl[cl.length - 1];
    };
  const peg$c309 = peg$otherExpectation("CONSTRAINT Name");
  const peg$c310 = function(n: any): any {
      return {
        'name': n
      };
    };
  const peg$c311 = peg$otherExpectation("FOREIGN KEY Column Constraint");
  const peg$c312 = function(f: any): any {
      return Object.assign({
        'variant': 'foreign key'
      }, f);
    };
  const peg$c313 = peg$otherExpectation("PRIMARY KEY Column Constraint");
  const peg$c314 = function(p: any, d: any, c: any, a: any): any {
      return Object.assign(p, c, d, a);
    };
  const peg$c315 = peg$otherExpectation("PRIMARY KEY Keyword");
  const peg$c316 = function(s: any, k: any): any {
      return {
        'type': 'constraint',
        'variant': foldStringKey([ s, k ])
      };
    };
  const peg$c317 = peg$otherExpectation("AUTOINCREMENT Keyword");
  const peg$c318 = function(a: any): any {
      return {
        'autoIncrement': true
      };
    };
  const peg$c319 = function(s: any, c: any): any {
      return Object.assign({
        'type': 'constraint',
        'variant': s
      }, c);
    };
  const peg$c320 = peg$otherExpectation("UNIQUE Column Constraint");
  const peg$c321 = peg$otherExpectation("NULL Column Constraint");
  const peg$c322 = function(n: any, l: any): any { return foldStringKey([ n, l ]); };
  const peg$c323 = peg$otherExpectation("CHECK Column Constraint");
  const peg$c324 = peg$otherExpectation("DEFAULT Column Constraint");
  const peg$c325 = function(s: any, v: any): any {
      return {
        'type': 'constraint',
        'variant': keyNode(s),
        'value': v
      };
    };
  const peg$c326 = peg$otherExpectation("COLLATE Column Constraint");
  const peg$c327 = function(c: any): any {
      return {
        'type': 'constraint',
        'variant': 'collate',
        'collate': c
      };
    };
  const peg$c328 = peg$otherExpectation("Table Constraint");
  const peg$c329 = function(n: any, c: any, nl: any): any {
      return Object.assign({
        'type': 'definition',
        'variant': 'constraint'
      }, c, n);
    };
  const peg$c330 = peg$otherExpectation("CHECK Table Constraint");
  const peg$c331 = function(c: any): any {
      return {
        'definition': makeArray(c)
      };
    };
  const peg$c332 = peg$otherExpectation("PRIMARY KEY Table Constraint");
  const peg$c333 = function(k: any, c: any, t: any): any {
      return {
        'definition': makeArray(Object.assign(k, t, c[1])),
        'columns': c[0]
      };
    };
  const peg$c334 = function(s: any): any {
      return {
        'type': 'constraint',
        'variant': keyNode(s)
      };
    };
  const peg$c335 = function(p: any, k: any): any { return foldStringKey([ p, k ]); };
  const peg$c336 = peg$otherExpectation("UNIQUE Keyword");
  const peg$c337 = function(u: any): any { return keyNode(u); };
  const peg$c338 = function(f: any, b: any): any {
      return [f].concat(b);
    };
  const peg$c339 = function(c: any): any {
      return c.map(([ res ]) => res);
    };
  const peg$c340 = function(c: any): any {
      const auto = c.find(([ res, a ]) => isOkay(a));
      return [
        c.map(([ res, a ]) => res),
        auto ? auto[1] : null
      ];
    };
  const peg$c341 = peg$otherExpectation("Indexed Column");
  const peg$c342 = function(e: any, d: any, a: any): any {
      // Only convert this into an ordering expression if it contains
      // more than just the expression.
      let res = e;
      if (isOkay(d)) {
        res = Object.assign({
          'type': 'expression',
          'variant': 'order',
          'expression': e
        }, d);
      }
      return [ res, a ];
    };
  const peg$c343 = peg$otherExpectation("Collation");
  const peg$c344 = function(c: any): any {
      return {
        'collate': makeArray(c)
      };
    };
  const peg$c345 = peg$otherExpectation("Column Direction");
  const peg$c346 = function(t: any): any {
      return {
        'direction': keyNode(t),
      };
    };
  const peg$c347 = function(s: any, t: any): any {
      return {
        'conflict': keyNode(t)
      };
    };
  const peg$c348 = peg$otherExpectation("ON CONFLICT Keyword");
  const peg$c349 = function(o: any, c: any): any { return foldStringKey([ o, c ]); };
  const peg$c350 = function(k: any, c: any): any {
      return {
        'type': 'constraint',
        'variant': keyNode(k),
        'expression': c
      };
    };
  const peg$c351 = peg$otherExpectation("FOREIGN KEY Table Constraint");
  const peg$c352 = function(k: any, l: any, c: any): any {
      return Object.assign({
        'definition': makeArray(Object.assign(k, c))
      }, l);
    };
  const peg$c353 = peg$otherExpectation("FOREIGN KEY Keyword");
  const peg$c354 = function(f: any, k: any): any {
      return {
        'type': 'constraint',
        'variant': foldStringKey([ f, k ])
      };
    };
  const peg$c355 = function(r: any, a: any, d: any): any {
      return Object.assign({
        'type': 'constraint'
      }, r, a, d);
    };
  const peg$c356 = peg$otherExpectation("REFERENCES Clause");
  const peg$c357 = function(s: any, t: any): any {
      return {
        'references': t
      };
    };
  const peg$c358 = function(f: any, b: any): any {
      return {
        'action': flattenAll([ f, b ])
      };
    };
  const peg$c359 = peg$otherExpectation("FOREIGN KEY Action Clause");
  const peg$c360 = function(m: any, a: any, n: any): any {
      return {
        'type': 'action',
        'variant': keyNode(m),
        'action': keyNode(n)
      };
    };
  const peg$c361 = peg$otherExpectation("FOREIGN KEY Action");
  const peg$c362 = function(s: any, v: any): any { return foldStringKey([ s, v ]); };
  const peg$c363 = function(c: any): any { return keyNode(c); };
  const peg$c364 = function(n: any, a: any): any { return foldStringKey([ n, a ]); };
  const peg$c365 = function(m: any, n: any): any {
      return {
        'type': 'action',
        'variant': keyNode(m),
        'action': n
      };
    };
  const peg$c366 = peg$otherExpectation("DEFERRABLE Clause");
  const peg$c367 = function(n: any, d: any, i: any): any {
      return {
        'defer': foldStringKey([ n, d, i ])
      };
    };
  const peg$c368 = function(i: any, d: any): any { return foldStringKey([ i, d ]); };
  const peg$c369 = function(s: any): any {
      return {
        'definition': makeArray(s)
      };
    };
  const peg$c370 = peg$otherExpectation("CREATE INDEX Statement");
  const peg$c371 = function(s: any, ne: any, n: any, o: any, w: any): any {
      return Object.assign({
        'type': 'statement',
        'target': n,
        'on': o,
      }, s, ne, w);
    };
  const peg$c372 = function(s: any, u: any, i: any): any {
      return Object.assign({
        'variant': keyNode(s),
        'format': keyNode(i)
      }, u);
    };
  const peg$c373 = function(u: any): any {
      return {
        'unique': true
      };
    };
  const peg$c374 = peg$otherExpectation("ON Clause");
  const peg$c375 = function(o: any, t: any, c: any): any {
      return {
        'type': 'identifier',
        'variant': 'expression',
        'format': 'table',
        'name': t['name'],
        'columns': c
      };
    };
  const peg$c376 = peg$otherExpectation("CREATE TRIGGER Statement");
  const peg$c377 = function(s: any, ne: any, n: any, cd: any, o: any, me: any, wh: any, a: any): any {
      return Object.assign({
        'type': 'statement',
        'target': n,
        'on': o,
        'event': cd,
        'by': (isOkay(me) ? me : 'row'),
        'action': makeArray(a)
      }, s, ne, wh);
    };
  const peg$c378 = function(s: any, tmp: any, t: any): any {
      return Object.assign({
        'variant': keyNode(s),
        'format': keyNode(t)
      }, tmp);
    };
  const peg$c379 = peg$otherExpectation("Conditional Clause");
  const peg$c380 = function(m: any, d: any): any {
      return Object.assign({
        'type': 'event'
      }, m, d);
    };
  const peg$c381 = function(m: any): any {
      return {
        'occurs': keyNode(m)
      };
    };
  const peg$c382 = function(i: any, o: any): any { return foldStringKey([ i, o ]); };
  const peg$c383 = peg$otherExpectation("Conditional Action");
  const peg$c384 = function(o: any): any {
      return {
        'event': keyNode(o)
      };
    };
  const peg$c385 = function(s: any, f: any): any {
      return {
        'event': keyNode(s),
        'of': f
      };
    };
  const peg$c386 = function(s: any, c: any): any { return c; };
  const peg$c387 = "statement";
  const peg$c388 = peg$literalExpectation("STATEMENT", true);
  const peg$c389 = function(f: any, e: any, r: any): any { return keyNode(r); };
  const peg$c390 = function(w: any, e: any): any {
      return {
        'when': e
      };
    };
  const peg$c391 = peg$otherExpectation("Actions Clause");
  const peg$c392 = function(s: any, a: any, e: any): any { return a; };
  const peg$c393 = function(l: any): any { return l; };
  const peg$c394 = peg$otherExpectation("CREATE VIEW Statement");
  const peg$c395 = function(s: any, ne: any, n: any, r: any): any {
      return Object.assign({
        'type': 'statement',
        'target': n,
        'result': r
      }, s, ne);
    };
  const peg$c396 = function(n: any, a: any): any {
      return Object.assign({
        'type': 'identifier',
        'variant': 'expression',
        'format': 'view',
        'name': n['name'],
        'columns': []
      }, a);
    };
  const peg$c397 = function(s: any, tmp: any, v: any): any {
      return Object.assign({
        'variant': keyNode(s),
        'format': keyNode(v)
      }, tmp);
    };
  const peg$c398 = peg$otherExpectation("CREATE VIRTUAL TABLE Statement");
  const peg$c399 = function(s: any, ne: any, n: any, m: any): any {
      return Object.assign({
        'type': 'statement',
        'target': n,
        'result': m
      }, s, ne);
    };
  const peg$c400 = function(s: any, v: any, t: any): any {
      return {
        'variant': keyNode(s),
        'format': keyNode(v)
      };
    };
  const peg$c401 = function(m: any, a: any): any {
      return Object.assign({
        'type': 'module',
        'variant': 'virtual',
        'name': m
      }, a);
    };
  const peg$c402 = peg$otherExpectation("Module Arguments");
  const peg$c403 = function(l: any): any {
      return {
        'args': {
          'type': 'expression',
          'variant': 'list',
          'expression': isOkay(l) ? l : []
        }
      };
    };
  const peg$c404 = function(f: any, b: any): any {
      return flattenAll([ f, b ]).filter((arg) => isOkay(arg));
    };
  const peg$c405 = function(a: any): any {
      return a;
    };
  const peg$c406 = peg$otherExpectation("DROP Statement");
  const peg$c407 = function(s: any, q: any): any {
      /**
       * @note Manually copy in the correct variant for the target
       */
      return Object.assign({
        'type': 'statement',
        'target': Object.assign(q, {
                    'variant': s['format']
                  })
      }, s);
    };
  const peg$c408 = peg$otherExpectation("DROP Keyword");
  const peg$c409 = function(s: any, t: any, i: any): any {
       return Object.assign({
         'variant': keyNode(s),
         'format': t,
         'condition': []
       }, i);
    };
  const peg$c410 = peg$otherExpectation("DROP Type");
  const peg$c411 = peg$otherExpectation("IF EXISTS Keyword");
  const peg$c412 = function(i: any, e: any): any {
      return {
        'condition': [{
          'type': 'condition',
          'variant': keyNode(i),
          'condition': {
            'type': 'expression',
            'variant': keyNode(e),
            'operator': keyNode(e)
          }
        }]
      };
    };
  const peg$c413 = peg$otherExpectation("Or");
  const peg$c414 = peg$otherExpectation("Add");
  const peg$c415 = peg$otherExpectation("Subtract");
  const peg$c416 = peg$otherExpectation("Multiply");
  const peg$c417 = peg$otherExpectation("Divide");
  const peg$c418 = peg$otherExpectation("Modulo");
  const peg$c419 = peg$otherExpectation("Shift Left");
  const peg$c420 = peg$otherExpectation("Shift Right");
  const peg$c421 = peg$otherExpectation("Logical AND");
  const peg$c422 = peg$otherExpectation("Logical OR");
  const peg$c423 = peg$otherExpectation("Less Than");
  const peg$c424 = peg$otherExpectation("Greater Than");
  const peg$c425 = peg$otherExpectation("Less Than Or Equal");
  const peg$c426 = peg$otherExpectation("Greater Than Or Equal");
  const peg$c427 = peg$otherExpectation("Equal");
  const peg$c428 = peg$otherExpectation("Not Equal");
  const peg$c429 = peg$otherExpectation("IS");
  const peg$c430 = function(i: any, n: any): any { return foldStringKey([ i, n ]); };
  const peg$c431 = peg$otherExpectation("Identifier");
  const peg$c432 = peg$otherExpectation("Database Identifier");
  const peg$c433 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'database',
        'name': n
      };
    };
  const peg$c434 = peg$otherExpectation("Function Identifier");
  const peg$c435 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        // TODO: Should this be `table function` since it is table-function name
        'variant': 'function',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c436 = peg$otherExpectation("Table Identifier");
  const peg$c437 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'table',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c438 = function(n: any, d: any): any { return foldStringWord([ n, d ]); };
  const peg$c439 = peg$otherExpectation("Column Identifier");
  const peg$c440 = function(q: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'column',
        'name': foldStringWord([ q, n ])
      };
    };
  const peg$c441 = function(): any { return ''; };
  const peg$c442 = function(d: any, t: any): any { return foldStringWord([ d, t ]); };
  const peg$c443 = peg$otherExpectation("Collation Identifier");
  const peg$c444 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'collation',
        'name': n
      };
    };
  const peg$c445 = peg$otherExpectation("Savepoint Identifier");
  const peg$c446 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'savepoint',
        'name': n
      };
    };
  const peg$c447 = peg$otherExpectation("Index Identifier");
  const peg$c448 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'index',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c449 = peg$otherExpectation("Trigger Identifier");
  const peg$c450 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'trigger',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c451 = peg$otherExpectation("View Identifier");
  const peg$c452 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'view',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c453 = peg$otherExpectation("Pragma Identifier");
  const peg$c454 = function(d: any, n: any): any {
      return {
        'type': 'identifier',
        'variant': 'pragma',
        'name': foldStringWord([ d, n ])
      };
    };
  const peg$c455 = peg$otherExpectation("CTE Identifier");
  const peg$c456 = function(d: any): any {
      return d;
    };
  const peg$c457 = function(n: any, a: any): any {
      return Object.assign({
        'type': 'identifier',
        'variant': 'expression',
        'format': 'table',
        'name': n['name'],
        'columns': []
      }, a);
    };
  const peg$c458 = peg$otherExpectation("Table Constraint Identifier");
  const peg$c459 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'constraint',
        'format': 'table',
        'name': n
      };
    };
  const peg$c460 = peg$otherExpectation("Column Constraint Identifier");
  const peg$c461 = function(n: any): any {
      return {
        'type': 'identifier',
        'variant': 'constraint',
        'format': 'column',
        'name': n
      };
    };
  const peg$c462 = peg$otherExpectation("Datatype Name");
  const peg$c463 = function(t: any): any { return [t, 'text']; };
  const peg$c464 = function(t: any): any { return [t, 'real']; };
  const peg$c465 = function(t: any): any { return [t, 'numeric']; };
  const peg$c466 = function(t: any): any { return [t, 'integer']; };
  const peg$c467 = function(t: any): any { return [t, 'none']; };
  const peg$c468 = peg$otherExpectation("TEXT Datatype Name");
  const peg$c469 = "n";
  const peg$c470 = peg$literalExpectation("N", true);
  const peg$c471 = "var";
  const peg$c472 = peg$literalExpectation("VAR", true);
  const peg$c473 = "char";
  const peg$c474 = peg$literalExpectation("CHAR", true);
  const peg$c475 = "tiny";
  const peg$c476 = peg$literalExpectation("TINY", true);
  const peg$c477 = "medium";
  const peg$c478 = peg$literalExpectation("MEDIUM", true);
  const peg$c479 = "long";
  const peg$c480 = peg$literalExpectation("LONG", true);
  const peg$c481 = "text";
  const peg$c482 = peg$literalExpectation("TEXT", true);
  const peg$c483 = "clob";
  const peg$c484 = peg$literalExpectation("CLOB", true);
  const peg$c485 = peg$otherExpectation("REAL Datatype Name");
  const peg$c486 = "float";
  const peg$c487 = peg$literalExpectation("FLOAT", true);
  const peg$c488 = "real";
  const peg$c489 = peg$literalExpectation("REAL", true);
  const peg$c490 = peg$otherExpectation("DOUBLE Datatype Name");
  const peg$c491 = "double";
  const peg$c492 = peg$literalExpectation("DOUBLE", true);
  const peg$c493 = "precision";
  const peg$c494 = peg$literalExpectation("PRECISION", true);
  const peg$c495 = function(d: any, p: any): any { return foldStringWord([ d, p ]); };
  const peg$c496 = peg$otherExpectation("NUMERIC Datatype Name");
  const peg$c497 = "numeric";
  const peg$c498 = peg$literalExpectation("NUMERIC", true);
  const peg$c499 = "decimal";
  const peg$c500 = peg$literalExpectation("DECIMAL", true);
  const peg$c501 = "boolean";
  const peg$c502 = peg$literalExpectation("BOOLEAN", true);
  const peg$c503 = "date";
  const peg$c504 = peg$literalExpectation("DATE", true);
  const peg$c505 = "time";
  const peg$c506 = peg$literalExpectation("TIME", true);
  const peg$c507 = "stamp";
  const peg$c508 = peg$literalExpectation("STAMP", true);
  const peg$c509 = "string";
  const peg$c510 = peg$literalExpectation("STRING", true);
  const peg$c511 = peg$otherExpectation("INTEGER Datatype Name");
  const peg$c512 = "int";
  const peg$c513 = peg$literalExpectation("INT", true);
  const peg$c514 = "2";
  const peg$c515 = peg$literalExpectation("2", false);
  const peg$c516 = "4";
  const peg$c517 = peg$literalExpectation("4", false);
  const peg$c518 = "8";
  const peg$c519 = peg$literalExpectation("8", false);
  const peg$c520 = "eger";
  const peg$c521 = peg$literalExpectation("EGER", true);
  const peg$c522 = "big";
  const peg$c523 = peg$literalExpectation("BIG", true);
  const peg$c524 = "small";
  const peg$c525 = peg$literalExpectation("SMALL", true);
  const peg$c526 = "floating";
  const peg$c527 = peg$literalExpectation("FLOATING", true);
  const peg$c528 = "point";
  const peg$c529 = peg$literalExpectation("POINT", true);
  const peg$c530 = function(f: any, p: any): any {
      return foldStringWord([ f, p ]);
    };
  const peg$c531 = peg$otherExpectation("BLOB Datatype Name");
  const peg$c532 = "blob";
  const peg$c533 = peg$literalExpectation("BLOB", true);
  const peg$c534 = /^[a-z0-9$_]/i;
  const peg$c535 = peg$classExpectation([["a", "z"], ["0", "9"], "$", "_"], false, true);
  const peg$c536 = "\\u";
  const peg$c537 = peg$literalExpectation("\\u", false);
  const peg$c538 = /^[a-f0-9]/i;
  const peg$c539 = peg$classExpectation([["a", "f"], ["0", "9"]], false, true);
  const peg$c540 = function(u: any, s: any): any {
    return foldStringWord([ u, s ]).toLowerCase();
  };
  const peg$c541 = function(n: any): any {
     return keyNode(n);
    };
  const peg$c542 = peg$anyExpectation();
  const peg$c543 = function(n: any): any {
      return textNode(n);
    };
  const peg$c544 = /^[ \t]/;
  const peg$c545 = peg$classExpectation([" ", "\t"], false, false);
  const peg$c546 = "\"";
  const peg$c547 = peg$literalExpectation("\"", false);
  const peg$c548 = "\"\"";
  const peg$c549 = peg$literalExpectation("\"\"", false);
  const peg$c550 = /^[^"]/;
  const peg$c551 = peg$classExpectation(["\""], true, false);
  const peg$c552 = function(n: any): any { return unescape(n, '"'); };
  const peg$c553 = "'";
  const peg$c554 = peg$literalExpectation("'", false);
  const peg$c555 = function(n: any): any { return unescape(n, "'"); };
  const peg$c556 = "`";
  const peg$c557 = peg$literalExpectation("`", false);
  const peg$c558 = "``";
  const peg$c559 = peg$literalExpectation("``", false);
  const peg$c560 = /^[^`]/;
  const peg$c561 = peg$classExpectation(["`"], true, false);
  const peg$c562 = function(n: any): any { return unescape(n, '`'); };
  const peg$c563 = peg$otherExpectation("Open Bracket");
  const peg$c564 = "[";
  const peg$c565 = peg$literalExpectation("[", false);
  const peg$c566 = peg$otherExpectation("Close Bracket");
  const peg$c567 = "]";
  const peg$c568 = peg$literalExpectation("]", false);
  const peg$c569 = peg$otherExpectation("Open Parenthesis");
  const peg$c570 = "(";
  const peg$c571 = peg$literalExpectation("(", false);
  const peg$c572 = peg$otherExpectation("Close Parenthesis");
  const peg$c573 = ")";
  const peg$c574 = peg$literalExpectation(")", false);
  const peg$c575 = peg$otherExpectation("Comma");
  const peg$c576 = ",";
  const peg$c577 = peg$literalExpectation(",", false);
  const peg$c578 = peg$otherExpectation("Period");
  const peg$c579 = ".";
  const peg$c580 = peg$literalExpectation(".", false);
  const peg$c581 = peg$otherExpectation("Asterisk");
  const peg$c582 = "*";
  const peg$c583 = peg$literalExpectation("*", false);
  const peg$c584 = peg$otherExpectation("Question Mark");
  const peg$c585 = "?";
  const peg$c586 = peg$literalExpectation("?", false);
  const peg$c587 = peg$otherExpectation("Single Quote");
  const peg$c588 = peg$otherExpectation("Double Quote");
  const peg$c589 = peg$otherExpectation("Backtick");
  const peg$c590 = peg$otherExpectation("Tilde");
  const peg$c591 = "~";
  const peg$c592 = peg$literalExpectation("~", false);
  const peg$c593 = peg$otherExpectation("Plus");
  const peg$c594 = "+";
  const peg$c595 = peg$literalExpectation("+", false);
  const peg$c596 = peg$otherExpectation("Minus");
  const peg$c597 = "-";
  const peg$c598 = peg$literalExpectation("-", false);
  const peg$c599 = "=";
  const peg$c600 = peg$literalExpectation("=", false);
  const peg$c601 = peg$otherExpectation("Ampersand");
  const peg$c602 = "&";
  const peg$c603 = peg$literalExpectation("&", false);
  const peg$c604 = peg$otherExpectation("Pipe");
  const peg$c605 = "|";
  const peg$c606 = peg$literalExpectation("|", false);
  const peg$c607 = "%";
  const peg$c608 = peg$literalExpectation("%", false);
  const peg$c609 = "<";
  const peg$c610 = peg$literalExpectation("<", false);
  const peg$c611 = ">";
  const peg$c612 = peg$literalExpectation(">", false);
  const peg$c613 = peg$otherExpectation("Exclamation");
  const peg$c614 = "!";
  const peg$c615 = peg$literalExpectation("!", false);
  const peg$c616 = peg$otherExpectation("Semicolon");
  const peg$c617 = ";";
  const peg$c618 = peg$literalExpectation(";", false);
  const peg$c619 = peg$otherExpectation("Colon");
  const peg$c620 = peg$otherExpectation("Forward Slash");
  const peg$c621 = "/";
  const peg$c622 = peg$literalExpectation("/", false);
  const peg$c623 = peg$otherExpectation("Backslash");
  const peg$c624 = "\\";
  const peg$c625 = peg$literalExpectation("\\", false);
  const peg$c626 = "abort";
  const peg$c627 = peg$literalExpectation("ABORT", true);
  const peg$c628 = "action";
  const peg$c629 = peg$literalExpectation("ACTION", true);
  const peg$c630 = "add";
  const peg$c631 = peg$literalExpectation("ADD", true);
  const peg$c632 = "after";
  const peg$c633 = peg$literalExpectation("AFTER", true);
  const peg$c634 = "all";
  const peg$c635 = peg$literalExpectation("ALL", true);
  const peg$c636 = "alter";
  const peg$c637 = peg$literalExpectation("ALTER", true);
  const peg$c638 = "analyze";
  const peg$c639 = peg$literalExpectation("ANALYZE", true);
  const peg$c640 = "and";
  const peg$c641 = peg$literalExpectation("AND", true);
  const peg$c642 = "as";
  const peg$c643 = peg$literalExpectation("AS", true);
  const peg$c644 = "asc";
  const peg$c645 = peg$literalExpectation("ASC", true);
  const peg$c646 = "attach";
  const peg$c647 = peg$literalExpectation("ATTACH", true);
  const peg$c648 = "autoincrement";
  const peg$c649 = peg$literalExpectation("AUTOINCREMENT", true);
  const peg$c650 = "before";
  const peg$c651 = peg$literalExpectation("BEFORE", true);
  const peg$c652 = "begin";
  const peg$c653 = peg$literalExpectation("BEGIN", true);
  const peg$c654 = "between";
  const peg$c655 = peg$literalExpectation("BETWEEN", true);
  const peg$c656 = "by";
  const peg$c657 = peg$literalExpectation("BY", true);
  const peg$c658 = "cascade";
  const peg$c659 = peg$literalExpectation("CASCADE", true);
  const peg$c660 = "case";
  const peg$c661 = peg$literalExpectation("CASE", true);
  const peg$c662 = "cast";
  const peg$c663 = peg$literalExpectation("CAST", true);
  const peg$c664 = "check";
  const peg$c665 = peg$literalExpectation("CHECK", true);
  const peg$c666 = "collate";
  const peg$c667 = peg$literalExpectation("COLLATE", true);
  const peg$c668 = "column";
  const peg$c669 = peg$literalExpectation("COLUMN", true);
  const peg$c670 = "commit";
  const peg$c671 = peg$literalExpectation("COMMIT", true);
  const peg$c672 = "conflict";
  const peg$c673 = peg$literalExpectation("CONFLICT", true);
  const peg$c674 = "constraint";
  const peg$c675 = peg$literalExpectation("CONSTRAINT", true);
  const peg$c676 = "create";
  const peg$c677 = peg$literalExpectation("CREATE", true);
  const peg$c678 = "cross";
  const peg$c679 = peg$literalExpectation("CROSS", true);
  const peg$c680 = "current_date";
  const peg$c681 = peg$literalExpectation("CURRENT_DATE", true);
  const peg$c682 = "current_time";
  const peg$c683 = peg$literalExpectation("CURRENT_TIME", true);
  const peg$c684 = "current_timestamp";
  const peg$c685 = peg$literalExpectation("CURRENT_TIMESTAMP", true);
  const peg$c686 = "database";
  const peg$c687 = peg$literalExpectation("DATABASE", true);
  const peg$c688 = "default";
  const peg$c689 = peg$literalExpectation("DEFAULT", true);
  const peg$c690 = "deferrable";
  const peg$c691 = peg$literalExpectation("DEFERRABLE", true);
  const peg$c692 = "deferred";
  const peg$c693 = peg$literalExpectation("DEFERRED", true);
  const peg$c694 = "delete";
  const peg$c695 = peg$literalExpectation("DELETE", true);
  const peg$c696 = "desc";
  const peg$c697 = peg$literalExpectation("DESC", true);
  const peg$c698 = "detach";
  const peg$c699 = peg$literalExpectation("DETACH", true);
  const peg$c700 = "distinct";
  const peg$c701 = peg$literalExpectation("DISTINCT", true);
  const peg$c702 = "drop";
  const peg$c703 = peg$literalExpectation("DROP", true);
  const peg$c704 = "each";
  const peg$c705 = peg$literalExpectation("EACH", true);
  const peg$c706 = "else";
  const peg$c707 = peg$literalExpectation("ELSE", true);
  const peg$c708 = "end";
  const peg$c709 = peg$literalExpectation("END", true);
  const peg$c710 = "escape";
  const peg$c711 = peg$literalExpectation("ESCAPE", true);
  const peg$c712 = "except";
  const peg$c713 = peg$literalExpectation("EXCEPT", true);
  const peg$c714 = "exclusive";
  const peg$c715 = peg$literalExpectation("EXCLUSIVE", true);
  const peg$c716 = "exists";
  const peg$c717 = peg$literalExpectation("EXISTS", true);
  const peg$c718 = "explain";
  const peg$c719 = peg$literalExpectation("EXPLAIN", true);
  const peg$c720 = "fail";
  const peg$c721 = peg$literalExpectation("FAIL", true);
  const peg$c722 = "for";
  const peg$c723 = peg$literalExpectation("FOR", true);
  const peg$c724 = "foreign";
  const peg$c725 = peg$literalExpectation("FOREIGN", true);
  const peg$c726 = "from";
  const peg$c727 = peg$literalExpectation("FROM", true);
  const peg$c728 = "full";
  const peg$c729 = peg$literalExpectation("FULL", true);
  const peg$c730 = "glob";
  const peg$c731 = peg$literalExpectation("GLOB", true);
  const peg$c732 = "group";
  const peg$c733 = peg$literalExpectation("GROUP", true);
  const peg$c734 = "having";
  const peg$c735 = peg$literalExpectation("HAVING", true);
  const peg$c736 = "if";
  const peg$c737 = peg$literalExpectation("IF", true);
  const peg$c738 = "ignore";
  const peg$c739 = peg$literalExpectation("IGNORE", true);
  const peg$c740 = "immediate";
  const peg$c741 = peg$literalExpectation("IMMEDIATE", true);
  const peg$c742 = "in";
  const peg$c743 = peg$literalExpectation("IN", true);
  const peg$c744 = "index";
  const peg$c745 = peg$literalExpectation("INDEX", true);
  const peg$c746 = "indexed";
  const peg$c747 = peg$literalExpectation("INDEXED", true);
  const peg$c748 = "initially";
  const peg$c749 = peg$literalExpectation("INITIALLY", true);
  const peg$c750 = "inner";
  const peg$c751 = peg$literalExpectation("INNER", true);
  const peg$c752 = "insert";
  const peg$c753 = peg$literalExpectation("INSERT", true);
  const peg$c754 = "instead";
  const peg$c755 = peg$literalExpectation("INSTEAD", true);
  const peg$c756 = "intersect";
  const peg$c757 = peg$literalExpectation("INTERSECT", true);
  const peg$c758 = "into";
  const peg$c759 = peg$literalExpectation("INTO", true);
  const peg$c760 = "is";
  const peg$c761 = peg$literalExpectation("IS", true);
  const peg$c762 = "isnull";
  const peg$c763 = peg$literalExpectation("ISNULL", true);
  const peg$c764 = "join";
  const peg$c765 = peg$literalExpectation("JOIN", true);
  const peg$c766 = "key";
  const peg$c767 = peg$literalExpectation("KEY", true);
  const peg$c768 = "left";
  const peg$c769 = peg$literalExpectation("LEFT", true);
  const peg$c770 = "like";
  const peg$c771 = peg$literalExpectation("LIKE", true);
  const peg$c772 = "limit";
  const peg$c773 = peg$literalExpectation("LIMIT", true);
  const peg$c774 = "match";
  const peg$c775 = peg$literalExpectation("MATCH", true);
  const peg$c776 = "natural";
  const peg$c777 = peg$literalExpectation("NATURAL", true);
  const peg$c778 = "no";
  const peg$c779 = peg$literalExpectation("NO", true);
  const peg$c780 = "not";
  const peg$c781 = peg$literalExpectation("NOT", true);
  const peg$c782 = "notnull";
  const peg$c783 = peg$literalExpectation("NOTNULL", true);
  const peg$c784 = "of";
  const peg$c785 = peg$literalExpectation("OF", true);
  const peg$c786 = "offset";
  const peg$c787 = peg$literalExpectation("OFFSET", true);
  const peg$c788 = "on";
  const peg$c789 = peg$literalExpectation("ON", true);
  const peg$c790 = "or";
  const peg$c791 = peg$literalExpectation("OR", true);
  const peg$c792 = "order";
  const peg$c793 = peg$literalExpectation("ORDER", true);
  const peg$c794 = "outer";
  const peg$c795 = peg$literalExpectation("OUTER", true);
  const peg$c796 = "plan";
  const peg$c797 = peg$literalExpectation("PLAN", true);
  const peg$c798 = "pragma";
  const peg$c799 = peg$literalExpectation("PRAGMA", true);
  const peg$c800 = "primary";
  const peg$c801 = peg$literalExpectation("PRIMARY", true);
  const peg$c802 = "query";
  const peg$c803 = peg$literalExpectation("QUERY", true);
  const peg$c804 = "raise";
  const peg$c805 = peg$literalExpectation("RAISE", true);
  const peg$c806 = "recursive";
  const peg$c807 = peg$literalExpectation("RECURSIVE", true);
  const peg$c808 = "references";
  const peg$c809 = peg$literalExpectation("REFERENCES", true);
  const peg$c810 = "regexp";
  const peg$c811 = peg$literalExpectation("REGEXP", true);
  const peg$c812 = "reindex";
  const peg$c813 = peg$literalExpectation("REINDEX", true);
  const peg$c814 = "release";
  const peg$c815 = peg$literalExpectation("RELEASE", true);
  const peg$c816 = "rename";
  const peg$c817 = peg$literalExpectation("RENAME", true);
  const peg$c818 = "replace";
  const peg$c819 = peg$literalExpectation("REPLACE", true);
  const peg$c820 = "restrict";
  const peg$c821 = peg$literalExpectation("RESTRICT", true);
  const peg$c822 = "right";
  const peg$c823 = peg$literalExpectation("RIGHT", true);
  const peg$c824 = "rollback";
  const peg$c825 = peg$literalExpectation("ROLLBACK", true);
  const peg$c826 = "row";
  const peg$c827 = peg$literalExpectation("ROW", true);
  const peg$c828 = "rowid";
  const peg$c829 = peg$literalExpectation("ROWID", true);
  const peg$c830 = "savepoint";
  const peg$c831 = peg$literalExpectation("SAVEPOINT", true);
  const peg$c832 = "select";
  const peg$c833 = peg$literalExpectation("SELECT", true);
  const peg$c834 = "set";
  const peg$c835 = peg$literalExpectation("SET", true);
  const peg$c836 = "table";
  const peg$c837 = peg$literalExpectation("TABLE", true);
  const peg$c838 = "temp";
  const peg$c839 = peg$literalExpectation("TEMP", true);
  const peg$c840 = "temporary";
  const peg$c841 = peg$literalExpectation("TEMPORARY", true);
  const peg$c842 = "then";
  const peg$c843 = peg$literalExpectation("THEN", true);
  const peg$c844 = "to";
  const peg$c845 = peg$literalExpectation("TO", true);
  const peg$c846 = "transaction";
  const peg$c847 = peg$literalExpectation("TRANSACTION", true);
  const peg$c848 = "trigger";
  const peg$c849 = peg$literalExpectation("TRIGGER", true);
  const peg$c850 = "union";
  const peg$c851 = peg$literalExpectation("UNION", true);
  const peg$c852 = "unique";
  const peg$c853 = peg$literalExpectation("UNIQUE", true);
  const peg$c854 = "update";
  const peg$c855 = peg$literalExpectation("UPDATE", true);
  const peg$c856 = "using";
  const peg$c857 = peg$literalExpectation("USING", true);
  const peg$c858 = "vacuum";
  const peg$c859 = peg$literalExpectation("VACUUM", true);
  const peg$c860 = "values";
  const peg$c861 = peg$literalExpectation("VALUES", true);
  const peg$c862 = "view";
  const peg$c863 = peg$literalExpectation("VIEW", true);
  const peg$c864 = "virtual";
  const peg$c865 = peg$literalExpectation("VIRTUAL", true);
  const peg$c866 = "when";
  const peg$c867 = peg$literalExpectation("WHEN", true);
  const peg$c868 = "where";
  const peg$c869 = peg$literalExpectation("WHERE", true);
  const peg$c870 = "with";
  const peg$c871 = peg$literalExpectation("WITH", true);
  const peg$c872 = "without";
  const peg$c873 = peg$literalExpectation("WITHOUT", true);
  const peg$c874 = function(r: any): any { return keyNode(r); };
  const peg$c875 = function(): any { return null; };
  const peg$c876 = peg$otherExpectation("Line Comment");
  const peg$c877 = "--";
  const peg$c878 = peg$literalExpectation("--", false);
  const peg$c879 = /^[\n\v\f\r]/;
  const peg$c880 = peg$classExpectation(["\n", "\v", "\f", "\r"], false, false);
  const peg$c881 = peg$otherExpectation("Block Comment");
  const peg$c882 = "/*";
  const peg$c883 = peg$literalExpectation("/*", false);
  const peg$c884 = "*/";
  const peg$c885 = peg$literalExpectation("*/", false);
  const peg$c886 = /^[\n\v\f\r\t ]/;
  const peg$c887 = peg$classExpectation(["\n", "\v", "\f", "\r", "\t", " "], false, false);
  const peg$c888 = peg$otherExpectation("Whitespace");
  const peg$c889 = "__TODO__";
  const peg$c890 = peg$literalExpectation("__TODO__", false);

  let peg$currPos = 0;
  let peg$savedPos = 0;
  const peg$posDetailsCache = [{ line: 1, column: 1 }];
  let peg$maxFailPos = 0;
  let peg$maxFailExpected: Expectation[] = [];
  let peg$silentFails = 0;

  let peg$result;

  if (options.startRule !== undefined) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text(): string {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location(): FileRange {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description: string, location1?: FileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location1
    );
  }

  function error(message: string, location1?: FileRange) {
    location1 = location1 !== undefined
      ? location1
      : peg$computeLocation(peg$savedPos, peg$currPos);

    throw peg$buildSimpleError(message, location1);
  }

  function peg$literalExpectation(text1: string, ignoreCase: boolean): LiteralExpectation {
    return { type: "literal", text: text1, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts: ClassParts, inverted: boolean, ignoreCase: boolean): ClassExpectation {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation(): AnyExpectation {
    return { type: "any" };
  }

  function peg$endExpectation(): EndExpectation {
    return { type: "end" };
  }

  function peg$otherExpectation(description: string): OtherExpectation {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos: number) {
    let details = peg$posDetailsCache[pos];
    let p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;

      return details;
    }
  }

  function peg$computeLocation(startPos: number, endPos: number): FileRange {
    const startPosDetails = peg$computePosDetails(startPos);
    const endPosDetails = peg$computePosDetails(endPos);

    return {
      source: peg$source,
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected1: Expectation) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected1);
  }

  function peg$buildSimpleError(message: string, location1: FileRange) {
    return new PeggySyntaxError(message, [], "", location1);
  }

  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: FileRange) {
    return new PeggySyntaxError(
      PeggySyntaxError.buildMessage(expected1, found),
      expected1,
      found,
      location1
    );
  }

  function peg$parsestart(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesemi_optional();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_list();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesemi_optional();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestart_streaming(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesemi_optional();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesemi_optional();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_list(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsestmt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsestmt_list_tail();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsestmt_list_tail();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c1(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesemi_optional(): any {
    let s0, s1;

    s0 = [];
    s1 = peg$parsesym_semi();
    while (s1 as any !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsesym_semi();
    }

    return s0;
  }

  function peg$parsesemi_required(): any {
    let s0, s1;

    s0 = [];
    s1 = peg$parsesym_semi();
    if (s1 as any !== peg$FAILED) {
      while (s1 as any !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsesym_semi();
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_list_tail(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesemi_required();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetype_definition(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsetype_definition_types();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsedatatype_custom();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetype_definition_args();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c4(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c3); }
    }

    return s0;
  }

  function peg$parsetype_definition_types(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsedatatype_types();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c5(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsedatatype_custom(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsedatatype_word_tail();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsedatatype_word_tail();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c7(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }

    return s0;
  }

  function peg$parsedatatype_word_tail(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    if (peg$c8.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c9); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsename_unquoted();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c10(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetype_definition_args(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseliteral_number_signed();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsedefinition_args_loop();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesym_pclose();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c12(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c11); }
    }

    return s0;
  }

  function peg$parsedefinition_args_loop(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseliteral_number_signed();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c13(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseliteral_value(): any {
    let s0;

    s0 = peg$parseliteral_number_signed();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseliteral_number();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseliteral_blob();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseliteral_null();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseliteral_date();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parseliteral_string();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseliteral_null(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseNULL();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c15(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c14); }
    }

    return s0;
  }

  function peg$parseliteral_date(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCURRENT_DATE();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseCURRENT_TIMESTAMP();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseCURRENT_TIME();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c17(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c16); }
    }

    return s0;
  }

  function peg$parseliteral_string(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsenumber_sign();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseliteral_string_single();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c19(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c18); }
    }

    return s0;
  }

  function peg$parseliteral_string_single(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_sglquote();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseliteral_string_schar();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseliteral_string_schar();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_sglquote();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c21(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c20); }
    }

    return s0;
  }

  function peg$parseliteral_string_schar(): any {
    let s0;

    if (input.substr(peg$currPos, 2) === peg$c22) {
      s0 = peg$c22;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    if (s0 as any === peg$FAILED) {
      if (peg$c24.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
    }

    return s0;
  }

  function peg$parseliteral_blob(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (peg$c27.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseliteral_string_single();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c26); }
    }

    return s0;
  }

  function peg$parseliteral_text(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsename_unquoted();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsename_dblquoted();
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c30(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsenumber_sign(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_plus();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsesym_minus();
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c2(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c31); }
    }

    return s0;
  }

  function peg$parseliteral_number_signed(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenumber_sign();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseliteral_number();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c32(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseliteral_number(): any {
    let s0;

    s0 = peg$parseliteral_number_hex();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseliteral_number_decimal();
    }

    return s0;
  }

  function peg$parseliteral_number_decimal(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsenumber_decimal_node();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsenumber_decimal_exponent();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c33(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenumber_decimal_node(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsenumber_decimal_full();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsenumber_decimal_fraction();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c34); }
    }

    return s0;
  }

  function peg$parsenumber_decimal_full(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsenumber_digit();
    if (s2 as any !== peg$FAILED) {
      while (s2 as any !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsenumber_digit();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsenumber_decimal_fraction();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c35(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenumber_decimal_fraction(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_dot();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_digit();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsenumber_digit();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c36(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsenumber_decimal_exponent(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c38) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 as any !== peg$FAILED) {
      if (peg$c40.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsenumber_digit();
        if (s4 as any !== peg$FAILED) {
          while (s4 as any !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsenumber_digit();
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c42(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c37); }
    }

    return s0;
  }

  function peg$parseliteral_number_hex(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c44) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c45); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_hex();
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsenumber_hex();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c43); }
    }

    return s0;
  }

  function peg$parsenumber_hex(): any {
    let s0;

    if (peg$c47.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }

    return s0;
  }

  function peg$parsenumber_digit(): any {
    let s0;

    if (peg$c49.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c50); }
    }

    return s0;
  }

  function peg$parsebind_parameter(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsebind_parameter_numbered();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsebind_parameter_named();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parsebind_parameter_tcl();
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c52(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c51); }
    }

    return s0;
  }

  function peg$parsebind_parameter_numbered(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_quest();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsebind_number_id();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c54(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c53); }
    }

    return s0;
  }

  function peg$parsebind_number_id(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (peg$c55.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c56); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsenumber_digit();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsenumber_digit();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c57(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebind_parameter_named(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    if (peg$c59.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c60); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsename_char();
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsename_char();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c61(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c58); }
    }

    return s0;
  }

  function peg$parsebind_parameter_tcl(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 36) {
      s1 = peg$c63;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsename_char();
      if (s3 as any === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
      }
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsename_char();
          if (s3 as any === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s3 = peg$c65;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c66); }
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsetcl_suffix();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c67(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c62); }
    }

    return s0;
  }

  function peg$parsetcl_suffix(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsename_dblquoted();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c68(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_exists(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_exists_ne();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseselect_wrapped();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c70(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c69); }
    }

    return s0;
  }

  function peg$parseexpression_exists_ne(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseEXISTS();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c72(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c71); }
    }

    return s0;
  }

  function peg$parseexpression_raise(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseRAISE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_popen();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseexpression_raise_args();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parsesym_pclose();
                if (s7 as any !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c74(s1, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c73); }
    }

    return s0;
  }

  function peg$parseexpression_raise_args(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseraise_args_ignore();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseraise_args_message();
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c76(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c75); }
    }

    return s0;
  }

  function peg$parseraise_args_ignore(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseIGNORE();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c78(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c77); }
    }

    return s0;
  }

  function peg$parseraise_args_message(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseROLLBACK();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseABORT();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseFAIL();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_comma();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseerror_message();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c79(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_root(): any {
    let s0;

    s0 = peg$parsebind_parameter();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsefunction_call();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseliteral_value();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseid_column();
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_wrapped(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesym_pclose();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c80(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_recur(): any {
    let s0;

    s0 = peg$parseexpression_wrapped();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression_exists();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseexpression_cast();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseexpression_case();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseexpression_raise();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parseexpression_root();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_unary_collate(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_recur();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_collate();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c81(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression_recur();
    }

    return s0;
  }

  function peg$parseexpression_unary(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_unary_op();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_unary_collate();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseexpression();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c82(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression_unary_collate();
    }

    return s0;
  }

  function peg$parseexpression_unary_op(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$parsesym_tilde();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsesym_minus();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsesym_plus();
        if (s0 as any === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseexpression_is_not();
          if (s2 as any !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseEXISTS();
            peg$silentFails--;
            if (s4 as any === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 as any !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 as any !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_collate(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecolumn_collate();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c84(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c83); }
    }

    return s0;
  }

  function peg$parseexpression_concat(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_unary();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parsebinary_concat();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_unary();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parsebinary_concat();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_unary();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_multiply(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_concat();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseexpression_multiply_op();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_concat();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseexpression_multiply_op();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_concat();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_multiply_op(): any {
    let s0;

    s0 = peg$parsebinary_multiply();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebinary_divide();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsebinary_mod();
      }
    }

    return s0;
  }

  function peg$parseexpression_add(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_multiply();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseexpression_add_op();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_multiply();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseexpression_add_op();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_multiply();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_add_op(): any {
    let s0;

    s0 = peg$parsebinary_plus();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebinary_minus();
    }

    return s0;
  }

  function peg$parseexpression_shift(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_add();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseexpression_shift_op();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_add();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseexpression_shift_op();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_add();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_shift_op(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$parsebinary_left();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebinary_right();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsebinary_and();
        if (s0 as any === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsebinary_or();
          if (s2 as any !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parsebinary_or();
            peg$silentFails--;
            if (s4 as any === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 as any !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 as any !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_compare(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_shift();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseexpression_compare_op();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_shift();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseexpression_compare_op();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_shift();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_compare_op(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$parsebinary_lte();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebinary_gte();
      if (s0 as any === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsebinary_lt();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseexpression_shift_op();
          peg$silentFails--;
          if (s4 as any === peg$FAILED) {
            s3 = undefined;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 as any !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 as any !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        if (s0 as any === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsebinary_gt();
          if (s2 as any !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseexpression_shift_op();
            peg$silentFails--;
            if (s4 as any === peg$FAILED) {
              s3 = undefined;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 as any !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 as any !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_equiv(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_compare();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseexpression_equiv_tails();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseexpression_equiv_tails();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_equiv_tails(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression_equiv_null_op();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c86(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseo();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseexpression_equiv_op();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parseo();
          if (s3 as any !== peg$FAILED) {
            s4 = peg$parseexpression_compare();
            if (s4 as any !== peg$FAILED) {
              s1 = [s1, s2, s3, s4];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parseexpression_equiv_null_op(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c87) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c88); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c89) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c90); }
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c91();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseISNULL();
      if (s1 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c92();
      }
      s0 = s1;
      if (s0 as any === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNOTNULL();
        if (s1 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c91();
        }
        s0 = s1;
      }
    }

    return s0;
  }

  function peg$parseexpression_equiv_op(): any {
    let s0;

    s0 = peg$parsebinary_lang_isnt();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebinary_notequal_a();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsebinary_notequal_b();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsebinary_equal();
        }
      }
    }

    return s0;
  }

  function peg$parseexpression_cast(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCAST();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_popen();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parsetype_alias();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseo();
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parsesym_pclose();
                  if (s8 as any !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c94(s1, s4, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c93); }
    }

    return s0;
  }

  function peg$parsetype_alias(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetype_definition();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c96(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c95); }
    }

    return s0;
  }

  function peg$parseexpression_case(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCASE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecase_expression();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = [];
            s6 = peg$parseexpression_case_when();
            if (s6 as any !== peg$FAILED) {
              while (s6 as any !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseexpression_case_when();
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseexpression_case_else();
                if (s7 as any === peg$FAILED) {
                  s7 = null;
                }
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseo();
                  if (s8 as any !== peg$FAILED) {
                    s9 = peg$parseEND();
                    if (s9 as any !== peg$FAILED) {
                      s10 = peg$parseo();
                      if (s10 as any !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c98(s1, s3, s5, s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c97); }
    }

    return s0;
  }

  function peg$parsecase_expression(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$parseWHEN();
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c99(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_case_when(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseWHEN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseTHEN();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseexpression();
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseo();
                  if (s8 as any !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c101(s1, s3, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c100); }
    }

    return s0;
  }

  function peg$parseexpression_case_else(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseELSE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c103(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c102); }
    }

    return s0;
  }

  function peg$parseexpression_postfix(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_equiv();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_postfix_tail();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c104(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression_equiv();
    }

    return s0;
  }

  function peg$parseexpression_postfix_tail(): any {
    let s0;

    s0 = peg$parseexpression_in();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression_between();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseexpression_like();
      }
    }

    return s0;
  }

  function peg$parseexpression_like(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseLIKE();
      if (s2 as any === peg$FAILED) {
        s2 = peg$parseGLOB();
        if (s2 as any === peg$FAILED) {
          s2 = peg$parseREGEXP();
          if (s2 as any === peg$FAILED) {
            s2 = peg$parseMATCH();
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseexpression_escape();
              if (s6 as any === peg$FAILED) {
                s6 = null;
              }
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c106(s1, s2, s4, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c105); }
    }

    return s0;
  }

  function peg$parseexpression_escape(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseESCAPE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c108(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c107); }
    }

    return s0;
  }

  function peg$parseexpression_between(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseBETWEEN();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression_between_tail();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c110(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c109); }
    }

    return s0;
  }

  function peg$parseexpression_between_tail(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parseexpression_postfix();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parseo();
      if (s3 as any !== peg$FAILED) {
        s4 = peg$parseAND();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseo();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseexpression_postfix();
            if (s6 as any !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c111(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_is_not(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseNOT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c112(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_in(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseIN();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression_in_target();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c114(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c113); }
    }

    return s0;
  }

  function peg$parseexpression_in_target(): any {
    let s0;

    s0 = peg$parseexpression_list_or_select();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseid_table();
    }

    return s0;
  }

  function peg$parseexpression_list_or_select(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_select_full();
      if (s2 as any === peg$FAILED) {
        s2 = peg$parseexpression_list();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c115(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_and(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_postfix();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseAND();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_postfix();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseAND();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_postfix();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseexpression_and();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseOR();
        if (s5 as any !== peg$FAILED) {
          s6 = peg$parseo();
          if (s6 as any !== peg$FAILED) {
            s7 = peg$parseexpression_and();
            if (s7 as any !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parseo();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseOR();
          if (s5 as any !== peg$FAILED) {
            s6 = peg$parseo();
            if (s6 as any !== peg$FAILED) {
              s7 = peg$parseexpression_and();
              if (s7 as any !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_list(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_list_loop();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c117(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c116); }
    }

    return s0;
  }

  function peg$parseexpression_list_loop(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseexpression_list_rest();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseexpression_list_rest();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c118(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_list_rest(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefunction_call(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_function();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_popen();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsefunction_call_args();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parsesym_pclose();
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c120(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c119); }
    }

    return s0;
  }

  function peg$parsefunction_call_args(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseselect_star();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c122(s1);
    }
    s0 = s1;
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parseargs_list_distinct();
      if (s1 as any === peg$FAILED) {
        s1 = null;
      }
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseexpression_list();
        if (s2 as any !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s3 = peg$c123(s1, s2);
          if (s3) {
            s3 = undefined;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c124(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c121); }
    }

    return s0;
  }

  function peg$parseargs_list_distinct(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseDISTINCT();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseALL();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c125(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseerror_message(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseliteral_string();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c127(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c126); }
    }

    return s0;
  }

  function peg$parsestmt(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsestmt_modifier();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_nodes();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c129(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c128); }
    }

    return s0;
  }

  function peg$parsestmt_modifier(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseEXPLAIN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsemodifier_query();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c131(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c130); }
    }

    return s0;
  }

  function peg$parsemodifier_query(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseQUERY();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsePLAN();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c133(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c132); }
    }

    return s0;
  }

  function peg$parsestmt_nodes(): any {
    let s0;

    s0 = peg$parsestmt_crud();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsestmt_create();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsestmt_drop();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsestmt_begin();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parsestmt_commit();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parsestmt_alter();
              if (s0 as any === peg$FAILED) {
                s0 = peg$parsestmt_rollback();
                if (s0 as any === peg$FAILED) {
                  s0 = peg$parsestmt_savepoint();
                  if (s0 as any === peg$FAILED) {
                    s0 = peg$parsestmt_release();
                    if (s0 as any === peg$FAILED) {
                      s0 = peg$parsestmt_sqlite();
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsestmt_commit(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCOMMIT();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseEND();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecommit_transaction();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c135(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c134); }
    }

    return s0;
  }

  function peg$parsestmt_begin(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseBEGIN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_begin_modifier();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsecommit_transaction();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesavepoint_name();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c137(s1, s3, s4, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c136); }
    }

    return s0;
  }

  function peg$parsecommit_transaction(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseTRANSACTION();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c138(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_begin_modifier(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseDEFERRED();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseIMMEDIATE();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseEXCLUSIVE();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c139(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_rollback(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseROLLBACK();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecommit_transaction();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parserollback_savepoint();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c141(s1, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c140); }
    }

    return s0;
  }

  function peg$parserollback_savepoint(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseTO();
    if (s2 as any !== peg$FAILED) {
      s3 = peg$parseo();
      if (s3 as any !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesavepoint_alt();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesavepoint_name();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c80(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c142); }
    }

    return s0;
  }

  function peg$parsesavepoint_name(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_savepoint();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c143(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesavepoint_alt(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseSAVEPOINT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_savepoint(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesavepoint_alt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesavepoint_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c146(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c145); }
    }

    return s0;
  }

  function peg$parsestmt_release(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseRELEASE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesavepoint_alt();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesavepoint_name();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c148(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c147); }
    }

    return s0;
  }

  function peg$parsestmt_alter(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsealter_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_table();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsealter_action();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c150(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c149); }
    }

    return s0;
  }

  function peg$parsealter_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseALTER();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTABLE();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c152(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c151); }
    }

    return s0;
  }

  function peg$parsealter_action(): any {
    let s0;

    s0 = peg$parsealter_action_rename();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsealter_action_add();
    }

    return s0;
  }

  function peg$parsealter_action_rename(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseRENAME();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTO();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseid_table();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c154(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c153); }
    }

    return s0;
  }

  function peg$parsealter_action_add(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseADD();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseaction_add_modifier();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesource_def_column();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c156(s1, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c155); }
    }

    return s0;
  }

  function peg$parseaction_add_modifier(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCOLUMN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_crud(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_with();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_crud_types();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c157(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_core_with(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseclause_with();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c10(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c158); }
    }

    return s0;
  }

  function peg$parseclause_with(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseWITH();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseclause_with_recursive();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseclause_with_tables();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c159(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseclause_with_recursive(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseRECURSIVE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseclause_with_tables(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseexpression_cte();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseclause_with_loop();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseclause_with_loop();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c160(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseclause_with_loop(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression_cte();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_cte(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_cte();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseselect_alias();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c162(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c161); }
    }

    return s0;
  }

  function peg$parseselect_alias(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseselect_wrapped();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c163(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_wrapped(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_select_full();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_select_full(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_with();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_select();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c164(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_sqlite(): any {
    let s0;

    s0 = peg$parsestmt_attach();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsestmt_detach();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsestmt_vacuum();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsestmt_analyze();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parsestmt_reindex();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parsestmt_pragma();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsestmt_attach(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseATTACH();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseDATABASE();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseo();
          if (s5 as any !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseAS();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseo();
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseattach_arg();
                  if (s8 as any !== peg$FAILED) {
                    s9 = peg$parseo();
                    if (s9 as any !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c166(s1, s3, s4, s8);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c165); }
    }

    return s0;
  }

  function peg$parseattach_arg(): any {
    let s0;

    s0 = peg$parseid_database();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseliteral_null();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsebind_parameter();
      }
    }

    return s0;
  }

  function peg$parsestmt_detach(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseDETACH();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseDATABASE();
        if (s4 as any !== peg$FAILED) {
          s5 = peg$parseo();
          if (s5 as any !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseattach_arg();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c168(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c167); }
    }

    return s0;
  }

  function peg$parsestmt_vacuum(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseVACUUM();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsevacuum_target();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c170(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c169); }
    }

    return s0;
  }

  function peg$parsevacuum_target(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_database();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c171(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_analyze(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseANALYZE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseanalyze_arg();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c173(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c172); }
    }

    return s0;
  }

  function peg$parseanalyze_arg(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseid_index();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseid_database();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c174(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_reindex(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseREINDEX();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsereindex_arg();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c173(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c175); }
    }

    return s0;
  }

  function peg$parsereindex_arg(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseid_index();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseid_collation();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c176(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_pragma(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsePRAGMA();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_pragma();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsepragma_expression();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c178(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c177); }
    }

    return s0;
  }

  function peg$parsepragma_expression(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsepragma_value();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c179(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsesym_equal();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parsepragma_value();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parseo();
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c179(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsepragma_value(): any {
    let s0;

    s0 = peg$parsepragma_value_bool();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsepragma_value_literal();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsepragma_value_name();
      }
    }

    return s0;
  }

  function peg$parsepragma_value_literal(): any {
    let s0;

    s0 = peg$parseliteral_number_signed();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseliteral_string();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseliteral_text();
      }
    }

    return s0;
  }

  function peg$parsepragma_value_bool(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsepragma_bool_id();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s2 = peg$c180(s1);
      if (s2) {
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c181(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepragma_bool_id(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsename_char();
    if (s2 as any !== peg$FAILED) {
      while (s2 as any !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsename_char();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c182(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsepragma_value_name(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsepragma_bool_id();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c183(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestmt_crud_types(): any {
    let s0;

    s0 = peg$parsestmt_select();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsestmt_insert();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsestmt_update();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsestmt_delete();
        }
      }
    }

    return s0;
  }

  function peg$parsestmt_select(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseselect_loop();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_core_order();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsestmt_core_limit();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c185(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c184); }
    }

    return s0;
  }

  function peg$parsestmt_core_order(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseORDER();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseBY();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsestmt_core_order_list();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c187(s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c186); }
    }

    return s0;
  }

  function peg$parsestmt_core_limit(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseLIMIT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsestmt_core_limit_offset();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c189(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c188); }
    }

    return s0;
  }

  function peg$parsestmt_core_limit_offset(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parselimit_offset_variant();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c191(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c190); }
    }

    return s0;
  }

  function peg$parselimit_offset_variant(): any {
    let s0;

    s0 = peg$parselimit_offset_variant_name();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsesym_comma();
    }

    return s0;
  }

  function peg$parselimit_offset_variant_name(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseOFFSET();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_loop(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseselect_parts();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseselect_loop_union();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseselect_loop_union();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c192(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_loop_union(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseoperator_compound();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseselect_parts();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c194(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c193); }
    }

    return s0;
  }

  function peg$parseselect_parts(): any {
    let s0;

    s0 = peg$parseselect_parts_core();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseselect_parts_values();
    }

    return s0;
  }

  function peg$parseselect_parts_core(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseselect_core_select();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseselect_core_from();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_core_where();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseselect_core_group();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c195(s1, s2, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_core_select(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseSELECT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseselect_modifier();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseselect_target();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c197(s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c196); }
    }

    return s0;
  }

  function peg$parseselect_modifier(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseselect_modifier_distinct();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseselect_modifier_all();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c198); }
    }

    return s0;
  }

  function peg$parseselect_modifier_distinct(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseDISTINCT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c199(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_modifier_all(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseALL();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c200(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_target(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseselect_node();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseselect_target_loop();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseselect_target_loop();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c160(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_target_loop(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseselect_node();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c13(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_core_from(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseFROM();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseselect_source();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c202(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c201); }
    }

    return s0;
  }

  function peg$parsestmt_core_where(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseWHERE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c204(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c203); }
    }

    return s0;
  }

  function peg$parseselect_core_group(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseGROUP();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseBY();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseexpression_list();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseselect_core_having();
                if (s7 as any === peg$FAILED) {
                  s7 = null;
                }
                if (s7 as any !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c206(s1, s5, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c205); }
    }

    return s0;
  }

  function peg$parseselect_core_having(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseHAVING();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c208(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c207); }
    }

    return s0;
  }

  function peg$parseselect_node(): any {
    let s0;

    s0 = peg$parseselect_node_star();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseselect_node_aliased();
    }

    return s0;
  }

  function peg$parseselect_node_star(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseselect_node_star_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseselect_star();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c209(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_node_star_qualified(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c210(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_node_aliased(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsealias();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c211(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_source(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsetable_or_sub();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesource_loop_tail();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesource_loop_tail();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c212(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesource_loop_tail(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseselect_cross_clause();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseselect_join_clause();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsejoin_condition();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c213(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect_cross_clause(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsetable_or_sub();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c215(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c214); }
    }

    return s0;
  }

  function peg$parseselect_join_clause(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsejoin_operator();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetable_or_sub();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c217(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c216); }
    }

    return s0;
  }

  function peg$parsetable_or_sub(): any {
    let s0;

    s0 = peg$parsetable_or_sub_sub();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsebind_parameter();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsetable_or_sub_func();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsetable_qualified();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parsetable_or_sub_select();
          }
        }
      }
    }

    return s0;
  }

  function peg$parsetable_or_sub_func(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseid_function();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_list_wrapped();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsealias();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c218(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetable_qualified(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsetable_qualified_id();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetable_or_sub_index_node();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c220(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c219); }
    }

    return s0;
  }

  function peg$parsetable_qualified_id(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsealias();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c222(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c221); }
    }

    return s0;
  }

  function peg$parsetable_or_sub_index_node(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseindex_node_indexed();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseindex_node_none();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c223); }
    }

    return s0;
  }

  function peg$parseindex_node_indexed(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parseINDEXED();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseBY();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseid_index();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c224(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseindex_node_none(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseINDEXED();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c225(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetable_or_sub_sub(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseselect_source();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsealias();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c227(s2, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c226); }
    }

    return s0;
  }

  function peg$parsetable_or_sub_select(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseselect_wrapped();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsealias();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c229(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c228); }
    }

    return s0;
  }

  function peg$parsealias(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parseAS();
    if (s2 as any !== peg$FAILED) {
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      s5 = peg$parsename_char();
      if (s5 as any === peg$FAILED) {
        s5 = peg$parsereserved_critical_list();
      }
      peg$silentFails--;
      if (s5 as any === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parseo();
        if (s5 as any !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      if (s3 as any !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsename();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c231(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c230); }
    }

    return s0;
  }

  function peg$parsejoin_operator(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsejoin_operator_natural();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsejoin_operator_types();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseJOIN();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c233(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c232); }
    }

    return s0;
  }

  function peg$parsejoin_operator_natural(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseNATURAL();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c112(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsejoin_operator_types(): any {
    let s0;

    s0 = peg$parseoperator_types_hand();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseoperator_types_misc();
    }

    return s0;
  }

  function peg$parseoperator_types_hand(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseLEFT();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseRIGHT();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseFULL();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetypes_hand_outer();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c234(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetypes_hand_outer(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseOUTER();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c235(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseoperator_types_misc(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseINNER();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseCROSS();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c235(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsejoin_condition(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsejoin_condition_on();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsejoin_condition_using();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c237(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c236); }
    }

    return s0;
  }

  function peg$parsejoin_condition_on(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c239(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c238); }
    }

    return s0;
  }

  function peg$parsejoin_condition_using(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseUSING();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseloop_columns();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c241(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c240); }
    }

    return s0;
  }

  function peg$parseselect_parts_values(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseVALUES();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseinsert_values_list();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c243(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c242); }
    }

    return s0;
  }

  function peg$parsestmt_core_order_list(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsestmt_core_order_list_item();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsestmt_core_order_list_loop();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsestmt_core_order_list_loop();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c244(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_core_order_list_loop(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_core_order_list_item();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c245(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_core_order_list_item(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseprimary_column_dir();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c247(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c246); }
    }

    return s0;
  }

  function peg$parseselect_star(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_star();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c248); }
    }

    return s0;
  }

  function peg$parsestmt_fallback_types(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseREPLACE();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseROLLBACK();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseABORT();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseFAIL();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseIGNORE();
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c249); }
    }

    return s0;
  }

  function peg$parsestmt_insert(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseinsert_keyword();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseinsert_target();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c251(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c250); }
    }

    return s0;
  }

  function peg$parseinsert_keyword(): any {
    let s0;

    s0 = peg$parseinsert_keyword_ins();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseinsert_keyword_repl();
    }

    return s0;
  }

  function peg$parseinsert_keyword_ins(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseINSERT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseinsert_keyword_mod();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c253(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c252); }
    }

    return s0;
  }

  function peg$parseinsert_keyword_repl(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseREPLACE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c255(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c254); }
    }

    return s0;
  }

  function peg$parseinsert_keyword_mod(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseOR();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_fallback_types();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c257(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c256); }
    }

    return s0;
  }

  function peg$parseinsert_target(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseinsert_into();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseinsert_results();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c258(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinsert_into(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseinsert_into_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_cte();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c260(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c259); }
    }

    return s0;
  }

  function peg$parseinsert_into_start(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseINTO();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c261); }
    }

    return s0;
  }

  function peg$parseinsert_results(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseinsert_value();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsestmt_select_full();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseinsert_default();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c262(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c242); }
    }

    return s0;
  }

  function peg$parseloop_columns(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseloop_name();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseloop_column_tail();
          while (s5 as any !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseloop_column_tail();
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesym_pclose();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c264(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c263); }
    }

    return s0;
  }

  function peg$parseloop_column_tail(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseloop_name();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c265(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseloop_name(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c267(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c266); }
    }

    return s0;
  }

  function peg$parseinsert_value(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseinsert_value_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseinsert_values_list();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c268(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c242); }
    }

    return s0;
  }

  function peg$parseinsert_value_start(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseVALUES();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c269); }
    }

    return s0;
  }

  function peg$parseinsert_values_list(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseexpression_list_wrapped();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseinsert_values_loop();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseinsert_values_loop();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c270(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinsert_values_loop(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression_list_wrapped();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c115(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseexpression_list_wrapped(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression_list();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c272(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c271); }
    }

    return s0;
  }

  function peg$parseinsert_default(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseDEFAULT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseVALUES();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c274(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c273); }
    }

    return s0;
  }

  function peg$parseoperator_compound(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecompound_union();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseINTERSECT();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseEXCEPT();
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c144(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c275); }
    }

    return s0;
  }

  function peg$parsecompound_union(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseUNION();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecompound_union_all();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c277(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c276); }
    }

    return s0;
  }

  function peg$parsecompound_union_all(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseALL();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c278(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsestmt_update(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseupdate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseupdate_fallback();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsetable_qualified();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseupdate_set();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parsestmt_core_where();
              if (s6 as any === peg$FAILED) {
                s6 = null;
              }
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parsestmt_core_order();
                if (s7 as any === peg$FAILED) {
                  s7 = null;
                }
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseo();
                  if (s8 as any !== peg$FAILED) {
                    s9 = peg$parsestmt_core_limit();
                    if (s9 as any === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 as any !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c280(s1, s2, s3, s5, s6, s7, s9);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c279); }
    }

    return s0;
  }

  function peg$parseupdate_start(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseUPDATE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c281); }
    }

    return s0;
  }

  function peg$parseupdate_fallback(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseOR();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_fallback_types();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c283(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c282); }
    }

    return s0;
  }

  function peg$parseupdate_set(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseSET();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseupdate_columns();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c285(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c284); }
    }

    return s0;
  }

  function peg$parseupdate_columns(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseupdate_column();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseupdate_columns_tail();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseupdate_columns_tail();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c270(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseupdate_columns_tail(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_comma();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseupdate_column();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c265(s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseupdate_column(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_column();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesym_equal();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseexpression();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c287(s1, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c286); }
    }

    return s0;
  }

  function peg$parsestmt_delete(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsedelete_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsetable_qualified();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsestmt_core_where();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsestmt_core_order();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parsestmt_core_limit();
              if (s6 as any === peg$FAILED) {
                s6 = null;
              }
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c289(s1, s2, s4, s5, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c288); }
    }

    return s0;
  }

  function peg$parsedelete_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseDELETE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseFROM();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c144(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c290); }
    }

    return s0;
  }

  function peg$parsestmt_create(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsecreate_table_only();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsecreate_index_only();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsecreate_trigger_only();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsecreate_view_only();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parsecreate_virtual_only();
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c291); }
    }

    return s0;
  }

  function peg$parsecreate_start(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCREATE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c144(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_table_only(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseINDEX();
      if (s4 as any === peg$FAILED) {
        s4 = peg$parseTRIGGER();
        if (s4 as any === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 as any === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
          }
        }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_table();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_index_only(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 as any === peg$FAILED) {
        s4 = peg$parseTRIGGER();
        if (s4 as any === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 as any === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
          }
        }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_index();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_trigger_only(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 as any === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 as any === peg$FAILED) {
          s4 = peg$parseVIEW();
          if (s4 as any === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
          }
        }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_trigger();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_view_only(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 as any === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 as any === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 as any === peg$FAILED) {
            s4 = peg$parseVIRTUAL();
          }
        }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_view();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_virtual_only(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsecreate_start();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseTABLE();
      if (s4 as any === peg$FAILED) {
        s4 = peg$parseINDEX();
        if (s4 as any === peg$FAILED) {
          s4 = peg$parseTRIGGER();
          if (s4 as any === peg$FAILED) {
            s4 = peg$parseVIEW();
          }
        }
      }
      if (s4 as any !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_virtual();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_table(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecreate_table_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_table();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsecreate_table_source();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c293(s1, s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c292); }
    }

    return s0;
  }

  function peg$parsecreate_table_start(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTABLE();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c294(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_core_tmp(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseTEMPORARY();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseTEMP();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c295(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_core_ine(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseIF();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_is_not();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseEXISTS();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c297(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c296); }
    }

    return s0;
  }

  function peg$parsecreate_table_source(): any {
    let s0;

    s0 = peg$parsetable_source_def();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsetable_source_select();
    }

    return s0;
  }

  function peg$parsetable_source_def(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesource_def_loop();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesource_tbl_loop();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesource_tbl_loop();
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsesym_pclose();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesource_def_rowid();
            if (s5 as any === peg$FAILED) {
              s5 = null;
            }
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c299(s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c298); }
    }

    return s0;
  }

  function peg$parsesource_def_rowid(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseWITHOUT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseROWID();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c300(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesource_def_loop(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsesource_def_column();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsesource_def_tail();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsesource_def_tail();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c270(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesource_def_tail(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesource_def_column();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c138(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesource_tbl_loop(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsetable_constraint();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c301(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesource_def_column(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesource_def_name();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecolumn_type();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsecolumn_constraints();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c303(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c302); }
    }

    return s0;
  }

  function peg$parsesource_def_name(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsename();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseo();
      peg$silentFails--;
      if (s3 as any !== peg$FAILED) {
        peg$currPos = s2;
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c80(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsecolumn_type();
      if (s2 as any === peg$FAILED) {
        s2 = peg$parsecolumn_constraint();
        if (s2 as any === peg$FAILED) {
          s2 = peg$parsetable_constraint();
        }
      }
      peg$silentFails--;
      if (s2 as any === peg$FAILED) {
        s1 = undefined;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 as any !== peg$FAILED) {
        s2 = peg$parseo();
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parsename_reserved();
          if (s3 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c80(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsecolumn_type(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsetype_definition();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c305(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c304); }
    }

    return s0;
  }

  function peg$parsecolumn_constraints(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsecolumn_constraint();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsecolumn_constraint_tail();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsecolumn_constraint_tail();
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c270(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolumn_constraint_tail(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecolumn_constraint();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c265(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecolumn_constraint(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecolumn_constraint_types();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseconstraint_name();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c307(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c306); }
    }

    return s0;
  }

  function peg$parseconstraint_name(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseconstraint_name_loop();
    if (s2 as any !== peg$FAILED) {
      while (s2 as any !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseconstraint_name_loop();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c308(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseconstraint_name_loop(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseCONSTRAINT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsename();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c310(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c309); }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_types(): any {
    let s0;

    s0 = peg$parsecolumn_constraint_primary();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsecolumn_constraint_null();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsecolumn_constraint_check();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsecolumn_constraint_default();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parsecolumn_constraint_collate();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parsecolumn_constraint_foreign();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_foreign(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseforeign_clause();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c312(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c311); }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_primary(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecol_primary_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseprimary_column_dir();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseprimary_conflict();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsecol_primary_auto();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c314(s1, s2, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c313); }
    }

    return s0;
  }

  function peg$parsecol_primary_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsePRIMARY();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parsePRAGMA();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseKEY();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c316(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c315); }
    }

    return s0;
  }

  function peg$parsecol_primary_auto(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseAUTOINCREMENT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c318(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c317); }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_null(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseconstraint_null_types();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseprimary_conflict();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c319(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseconstraint_null_types(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseconstraint_null_value();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseUNIQUE();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c235(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c320); }
    }

    return s0;
  }

  function peg$parseconstraint_null_value(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseNULL();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c322(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c321); }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_check(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseconstraint_check();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c323); }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_default(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseDEFAULT();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecolumn_default_values();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c325(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c324); }
    }

    return s0;
  }

  function peg$parsecolumn_default_values(): any {
    let s0;

    s0 = peg$parseexpression_wrapped();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseliteral_number_signed();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseliteral_value();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseliteral_text();
        }
      }
    }

    return s0;
  }

  function peg$parsecolumn_constraint_collate(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecolumn_collate();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c327(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c326); }
    }

    return s0;
  }

  function peg$parsetable_constraint(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseconstraint_name();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsetable_constraint_types();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseconstraint_name();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c329(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c328); }
    }

    return s0;
  }

  function peg$parsetable_constraint_types(): any {
    let s0;

    s0 = peg$parsetable_constraint_foreign();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsetable_constraint_primary();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsetable_constraint_check();
      }
    }

    return s0;
  }

  function peg$parsetable_constraint_check(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseconstraint_check();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c331(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c330); }
    }

    return s0;
  }

  function peg$parsetable_constraint_primary(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseprimary_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseprimary_columns_table();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseprimary_conflict();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c333(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c332); }
    }

    return s0;
  }

  function peg$parseprimary_start(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseprimary_start_normal();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseprimary_start_unique();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c334(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprimary_start_normal(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsePRIMARY();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseKEY();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c335(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c315); }
    }

    return s0;
  }

  function peg$parseprimary_start_unique(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseUNIQUE();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c337(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c336); }
    }

    return s0;
  }

  function peg$parseprimary_columns(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseprimary_column();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = [];
          s5 = peg$parseprimary_column_tail();
          while (s5 as any !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parseprimary_column_tail();
          }
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesym_pclose();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c338(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprimary_columns_index(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseprimary_columns();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c339(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseprimary_columns_table(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseprimary_columns();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c340(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseprimary_column_tail(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsesym_comma();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseprimary_column();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c265(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprimary_column(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseprimary_column_types();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseprimary_column_dir();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsecol_primary_auto();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c342(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c341); }
    }

    return s0;
  }

  function peg$parseprimary_column_types(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseloop_name();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$currPos;
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parsesym_semi();
        if (s5 as any === peg$FAILED) {
          s5 = peg$parsesym_pclose();
          if (s5 as any === peg$FAILED) {
            s5 = peg$parseprimary_column_dir();
          }
        }
        if (s5 as any !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      peg$silentFails--;
      if (s3 as any !== peg$FAILED) {
        peg$currPos = s2;
        s2 = undefined;
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c80(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseexpression();
    }

    return s0;
  }

  function peg$parsecolumn_collate(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsecolumn_collate_loop();
    if (s2 as any !== peg$FAILED) {
      while (s2 as any !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsecolumn_collate_loop();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c344(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c343); }
    }

    return s0;
  }

  function peg$parsecolumn_collate_loop(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseCOLLATE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_collation();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c80(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprimary_column_dir(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseASC();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseDESC();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c346(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c345); }
    }

    return s0;
  }

  function peg$parseprimary_conflict(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseprimary_conflict_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsestmt_fallback_types();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c347(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseprimary_conflict_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseCONFLICT();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c349(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c348); }
    }

    return s0;
  }

  function peg$parseconstraint_check(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseCHECK();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_wrapped();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c350(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetable_constraint_foreign(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseforeign_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseloop_columns();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseforeign_clause();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c352(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c351); }
    }

    return s0;
  }

  function peg$parseforeign_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseFOREIGN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseKEY();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c354(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c353); }
    }

    return s0;
  }

  function peg$parseforeign_clause(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseforeign_references();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseforeign_actions();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseforeign_deferrable();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c355(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseforeign_references(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseREFERENCES();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_cte();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c357(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c356); }
    }

    return s0;
  }

  function peg$parseforeign_actions(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseforeign_action();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseforeign_actions_tail();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseforeign_actions_tail();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c358(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseforeign_actions_tail(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseforeign_action();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c278(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseforeign_action(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseforeign_action_on();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseforeign_action_match();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c359); }
    }

    return s0;
  }

  function peg$parseforeign_action_on(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseDELETE();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseUPDATE();
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseaction_on_action();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c360(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseaction_on_action(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parseon_action_set();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseon_action_cascade();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseon_action_none();
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c361); }
    }

    return s0;
  }

  function peg$parseon_action_set(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseSET();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseNULL();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseDEFAULT();
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c362(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseon_action_cascade(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseCASCADE();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseRESTRICT();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c363(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseon_action_none(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseNO();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseACTION();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c364(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseforeign_action_match(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseMATCH();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsename();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c365(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseforeign_deferrable(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseexpression_is_not();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseDEFERRABLE();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsedeferrable_initially();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c367(s1, s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c366); }
    }

    return s0;
  }

  function peg$parsedeferrable_initially(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseINITIALLY();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseDEFERRED();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseIMMEDIATE();
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c368(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetable_source_select(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsecreate_as_select();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c369(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecreate_index(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecreate_index_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_index();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseindex_on();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parsestmt_core_where();
              if (s6 as any === peg$FAILED) {
                s6 = null;
              }
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c371(s1, s2, s3, s5, s6);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c370); }
    }

    return s0;
  }

  function peg$parsecreate_index_start(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseindex_unique();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseINDEX();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c372(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseindex_unique(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseUNIQUE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c373(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseindex_on(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseON();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_table();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseprimary_columns_index();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c375(s1, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c374); }
    }

    return s0;
  }

  function peg$parsecreate_trigger(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecreate_trigger_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_trigger();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsetrigger_conditions();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseON();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parseo();
                if (s7 as any !== peg$FAILED) {
                  s8 = peg$parseid_table();
                  if (s8 as any !== peg$FAILED) {
                    s9 = peg$parseo();
                    if (s9 as any !== peg$FAILED) {
                      s10 = peg$parsetrigger_foreach();
                      if (s10 as any === peg$FAILED) {
                        s10 = null;
                      }
                      if (s10 as any !== peg$FAILED) {
                        s11 = peg$parsetrigger_when();
                        if (s11 as any === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 as any !== peg$FAILED) {
                          s12 = peg$parsetrigger_action();
                          if (s12 as any !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c377(s1, s2, s3, s5, s8, s10, s11, s12);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c376); }
    }

    return s0;
  }

  function peg$parsecreate_trigger_start(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseTRIGGER();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c378(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_conditions(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsetrigger_apply_mods();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsetrigger_do();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c380(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c379); }
    }

    return s0;
  }

  function peg$parsetrigger_apply_mods(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseBEFORE();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseAFTER();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parsetrigger_apply_instead();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c381(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_apply_instead(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseINSTEAD();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseOF();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c382(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_do(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsetrigger_do_on();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsetrigger_do_update();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c383); }
    }

    return s0;
  }

  function peg$parsetrigger_do_on(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseDELETE();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseINSERT();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c384(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_do_update(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseUPDATE();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsedo_update_of();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c385(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedo_update_of(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseOF();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsedo_update_columns();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c386(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedo_update_columns(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseloop_name();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseloop_column_tail();
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseloop_column_tail();
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c270(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_foreach(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    s1 = peg$parseFOR();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseEACH();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseROW();
            if (s5 as any === peg$FAILED) {
              if (input.substr(peg$currPos, 9).toLowerCase() === peg$c387) {
                s5 = input.substr(peg$currPos, 9);
                peg$currPos += 9;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c388); }
              }
            }
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c389(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsetrigger_when(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseWHEN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c390(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c100); }
    }

    return s0;
  }

  function peg$parsetrigger_action(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseBEGIN();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseaction_loop();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseEND();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c392(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c391); }
    }

    return s0;
  }

  function peg$parseaction_loop(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseaction_loop_stmt();
    if (s2 as any !== peg$FAILED) {
      while (s2 as any !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseaction_loop_stmt();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c393(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseaction_loop_stmt(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsestmt_crud();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsesemi_required();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c2(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_view(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecreate_view_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_view_expression();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsecreate_as_select();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c395(s1, s2, s3, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c394); }
    }

    return s0;
  }

  function peg$parseid_view_expression(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseid_view();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseloop_columns();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c396(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseid_view();
    }

    return s0;
  }

  function peg$parsecreate_view_start(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_tmp();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseVIEW();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c397(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_as_select(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseAS();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsestmt_select();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c268(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecreate_virtual(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecreate_virtual_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecreate_core_ine();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseid_table();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseUSING();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                s7 = peg$parsevirtual_module();
                if (s7 as any !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c399(s1, s2, s3, s7);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c398); }
    }

    return s0;
  }

  function peg$parsecreate_virtual_start(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parsecreate_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseVIRTUAL();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseTABLE();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parseo();
            if (s5 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c400(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevirtual_module(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsename_unquoted();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsevirtual_args();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c401(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevirtual_args(): any {
    let s0, s1, s2, s3, s4, s5, s6;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_popen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsevirtual_args_loop();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s5 = peg$parsesym_pclose();
            if (s5 as any !== peg$FAILED) {
              s6 = peg$parseo();
              if (s6 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c403(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c402); }
    }

    return s0;
  }

  function peg$parsevirtual_args_loop(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsevirtual_arg_types();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsevirtual_args_tail();
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsevirtual_args_tail();
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c404(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevirtual_args_tail(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_comma();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsevirtual_arg_types();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c405(s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevirtual_arg_types(): any {
    let s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$currPos;
    s3 = peg$parsename();
    if (s3 as any !== peg$FAILED) {
      s4 = peg$parseo();
      if (s4 as any !== peg$FAILED) {
        s5 = peg$parsetype_definition();
        if (s5 as any === peg$FAILED) {
          s5 = peg$parsecolumn_constraint();
        }
        if (s5 as any !== peg$FAILED) {
          s3 = [s3, s4, s5];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseexpression();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c272(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsevirtual_column_name();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsename_char();
        peg$silentFails--;
        if (s4 as any === peg$FAILED) {
          s3 = undefined;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 as any !== peg$FAILED) {
          s3 = peg$parsecolumn_type();
          if (s3 as any === peg$FAILED) {
            s3 = null;
          }
          if (s3 as any !== peg$FAILED) {
            s4 = peg$parsecolumn_constraints();
            if (s4 as any === peg$FAILED) {
              s4 = null;
            }
            if (s4 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c303(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsevirtual_column_name(): any {
    let s0;

    s0 = peg$parsename();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsename_reserved();
    }

    return s0;
  }

  function peg$parsestmt_drop(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsedrop_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_table();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c407(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c406); }
    }

    return s0;
  }

  function peg$parsedrop_start(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseDROP();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsedrop_types();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsedrop_ie();
          if (s4 as any === peg$FAILED) {
            s4 = null;
          }
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c409(s1, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c408); }
    }

    return s0;
  }

  function peg$parsedrop_types(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseTABLE();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseINDEX();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parseTRIGGER();
        if (s1 as any === peg$FAILED) {
          s1 = peg$parseVIEW();
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c235(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c410); }
    }

    return s0;
  }

  function peg$parsedrop_ie(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseIF();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseEXISTS();
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parseo();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c412(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c411); }
    }

    return s0;
  }

  function peg$parsebinary_concat(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_pipe();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_pipe();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c413); }
    }

    return s0;
  }

  function peg$parsebinary_plus(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_plus();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c414); }
    }

    return s0;
  }

  function peg$parsebinary_minus(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_minus();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c415); }
    }

    return s0;
  }

  function peg$parsebinary_multiply(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_star();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c416); }
    }

    return s0;
  }

  function peg$parsebinary_divide(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_fslash();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c417); }
    }

    return s0;
  }

  function peg$parsebinary_mod(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_mod();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c418); }
    }

    return s0;
  }

  function peg$parsebinary_left(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_lt();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c419); }
    }

    return s0;
  }

  function peg$parsebinary_right(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_gt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_gt();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c420); }
    }

    return s0;
  }

  function peg$parsebinary_and(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_amp();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c421); }
    }

    return s0;
  }

  function peg$parsebinary_or(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_pipe();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c422); }
    }

    return s0;
  }

  function peg$parsebinary_lt(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_lt();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c423); }
    }

    return s0;
  }

  function peg$parsebinary_gt(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsesym_gt();
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c424); }
    }

    return s0;
  }

  function peg$parsebinary_lte(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c425); }
    }

    return s0;
  }

  function peg$parsebinary_gte(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_gt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c426); }
    }

    return s0;
  }

  function peg$parsebinary_equal(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_equal();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c427); }
    }

    return s0;
  }

  function peg$parsebinary_notequal_a(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_excl();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_equal();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c428); }
    }

    return s0;
  }

  function peg$parsebinary_notequal_b(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsesym_lt();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_gt();
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c428); }
    }

    return s0;
  }

  function peg$parsebinary_lang_isnt(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseIS();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseexpression_is_not();
        if (s3 as any === peg$FAILED) {
          s3 = null;
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c430(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c429); }
    }

    return s0;
  }

  function peg$parseid_name(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$parsename();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsename_reserved();
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c431); }
    }

    return s0;
  }

  function peg$parseid_database(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c433(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c432); }
    }

    return s0;
  }

  function peg$parseid_function(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c435(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c434); }
    }

    return s0;
  }

  function peg$parseid_table(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c437(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c436); }
    }

    return s0;
  }

  function peg$parseid_table_qualified(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c438(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseid_column(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecolumn_qualifiers();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseid_column_qualified();
      if (s1 as any === peg$FAILED) {
        s1 = peg$parsecolumn_unqualified();
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c440(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c439); }
    }

    return s0;
  }

  function peg$parsecolumn_unqualified(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parseo();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c441();
    }
    s0 = s1;

    return s0;
  }

  function peg$parsecolumn_qualifiers(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_column_qualified();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c442(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseid_column_qualified(): any {
    let s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_dot();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c36(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseid_collation(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c444(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c443); }
    }

    return s0;
  }

  function peg$parseid_savepoint(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c446(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c445); }
    }

    return s0;
  }

  function peg$parseid_index(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c448(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c447); }
    }

    return s0;
  }

  function peg$parseid_trigger(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c450(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c449); }
    }

    return s0;
  }

  function peg$parseid_view(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c452(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c451); }
    }

    return s0;
  }

  function peg$parseid_pragma(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_qualified();
    if (s1 as any === peg$FAILED) {
      s1 = null;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseid_name();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c454(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c453); }
    }

    return s0;
  }

  function peg$parseid_cte(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_table_expression();
    if (s1 as any === peg$FAILED) {
      s1 = peg$parseid_table();
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c456(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c455); }
    }

    return s0;
  }

  function peg$parseid_table_expression(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseid_table();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseloop_columns();
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c457(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseid_constraint_table(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c459(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c458); }
    }

    return s0;
  }

  function peg$parseid_constraint_column(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseid_name();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c461(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c460); }
    }

    return s0;
  }

  function peg$parsedatatype_types(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsedatatype_text();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c463(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsedatatype_real();
      if (s1 as any !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parsename_char();
        peg$silentFails--;
        if (s3 as any === peg$FAILED) {
          s2 = undefined;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c464(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 as any === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedatatype_numeric();
        if (s1 as any !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          s3 = peg$parsename_char();
          peg$silentFails--;
          if (s3 as any === peg$FAILED) {
            s2 = undefined;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c465(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 as any === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsedatatype_integer();
          if (s1 as any !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parsename_char();
            peg$silentFails--;
            if (s3 as any === peg$FAILED) {
              s2 = undefined;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 as any !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c466(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 as any === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedatatype_none();
            if (s1 as any !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parsename_char();
              peg$silentFails--;
              if (s3 as any === peg$FAILED) {
                s2 = undefined;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 as any !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c467(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c462); }
    }

    return s0;
  }

  function peg$parsedatatype_text(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 1).toLowerCase() === peg$c469) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c470); }
    }
    if (s2 as any === peg$FAILED) {
      s2 = null;
    }
    if (s2 as any !== peg$FAILED) {
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c471) {
        s3 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c472); }
      }
      if (s3 as any === peg$FAILED) {
        s3 = null;
      }
      if (s3 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c473) {
          s4 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c474); }
        }
        if (s4 as any !== peg$FAILED) {
          s2 = [s2, s3, s4];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4).toLowerCase() === peg$c475) {
        s2 = input.substr(peg$currPos, 4);
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c476); }
      }
      if (s2 as any === peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c477) {
          s2 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c478); }
        }
        if (s2 as any === peg$FAILED) {
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c479) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c480); }
          }
        }
      }
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c481) {
          s3 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c482); }
        }
        if (s3 as any !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 as any === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c483) {
          s1 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c484); }
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c235(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c468); }
    }

    return s0;
  }

  function peg$parsedatatype_real(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsedatatype_real_double();
    if (s1 as any === peg$FAILED) {
      if (input.substr(peg$currPos, 5).toLowerCase() === peg$c486) {
        s1 = input.substr(peg$currPos, 5);
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c487); }
      }
      if (s1 as any === peg$FAILED) {
        if (input.substr(peg$currPos, 4).toLowerCase() === peg$c488) {
          s1 = input.substr(peg$currPos, 4);
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c489); }
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c235(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c485); }
    }

    return s0;
  }

  function peg$parsedatatype_real_double(): any {
    let s0, s1, s2, s3, s4;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c491) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c492); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s4 as any !== peg$FAILED) {
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          if (peg$c8.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c9); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c493) {
          s4 = input.substr(peg$currPos, 9);
          peg$currPos += 9;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c494); }
        }
        if (s4 as any !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c495(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c490); }
    }

    return s0;
  }

  function peg$parsedatatype_numeric(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c497) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c498); }
    }
    if (s1 as any === peg$FAILED) {
      if (input.substr(peg$currPos, 7).toLowerCase() === peg$c499) {
        s1 = input.substr(peg$currPos, 7);
        peg$currPos += 7;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c500); }
      }
      if (s1 as any === peg$FAILED) {
        if (input.substr(peg$currPos, 7).toLowerCase() === peg$c501) {
          s1 = input.substr(peg$currPos, 7);
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c502); }
        }
        if (s1 as any === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 4).toLowerCase() === peg$c503) {
            s2 = input.substr(peg$currPos, 4);
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c504); }
          }
          if (s2 as any !== peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c505) {
              s3 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c506); }
            }
            if (s3 as any === peg$FAILED) {
              s3 = null;
            }
            if (s3 as any !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 as any === peg$FAILED) {
            s1 = peg$currPos;
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c505) {
              s2 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c506); }
            }
            if (s2 as any !== peg$FAILED) {
              if (input.substr(peg$currPos, 5).toLowerCase() === peg$c507) {
                s3 = input.substr(peg$currPos, 5);
                peg$currPos += 5;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c508); }
              }
              if (s3 as any === peg$FAILED) {
                s3 = null;
              }
              if (s3 as any !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 as any === peg$FAILED) {
              if (input.substr(peg$currPos, 6).toLowerCase() === peg$c509) {
                s1 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c510); }
              }
            }
          }
        }
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c235(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c496); }
    }

    return s0;
  }

  function peg$parsedatatype_integer(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c512) {
      s2 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c513); }
    }
    if (s2 as any !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 50) {
        s3 = peg$c514;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c515); }
      }
      if (s3 as any === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 52) {
          s3 = peg$c516;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c517); }
        }
        if (s3 as any === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 56) {
            s3 = peg$c518;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c519); }
          }
          if (s3 as any === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c520) {
              s3 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c521); }
            }
          }
        }
      }
      if (s3 as any !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any === peg$FAILED) {
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3).toLowerCase() === peg$c522) {
        s2 = input.substr(peg$currPos, 3);
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c523); }
      }
      if (s2 as any === peg$FAILED) {
        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c477) {
          s2 = input.substr(peg$currPos, 6);
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c478); }
        }
        if (s2 as any === peg$FAILED) {
          if (input.substr(peg$currPos, 5).toLowerCase() === peg$c524) {
            s2 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c525); }
          }
          if (s2 as any === peg$FAILED) {
            if (input.substr(peg$currPos, 4).toLowerCase() === peg$c475) {
              s2 = input.substr(peg$currPos, 4);
              peg$currPos += 4;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c476); }
            }
          }
        }
      }
      if (s2 as any === peg$FAILED) {
        s2 = null;
      }
      if (s2 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 3).toLowerCase() === peg$c512) {
          s3 = input.substr(peg$currPos, 3);
          peg$currPos += 3;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c513); }
        }
        if (s3 as any !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 as any === peg$FAILED) {
        s1 = peg$parsedatatype_integer_fp();
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c235(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c511); }
    }

    return s0;
  }

  function peg$parsedatatype_integer_fp(): any {
    let s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c526) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c527); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = [];
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s4 as any !== peg$FAILED) {
        while (s4 as any !== peg$FAILED) {
          s3.push(s4);
          if (peg$c8.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c9); }
          }
        }
      } else {
        s3 = peg$FAILED;
      }
      if (s3 as any !== peg$FAILED) {
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c528) {
          s4 = input.substr(peg$currPos, 5);
          peg$currPos += 5;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c529); }
        }
        if (s4 as any !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c530(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsedatatype_none(): any {
    let s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c532) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c533); }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c235(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c531); }
    }

    return s0;
  }

  function peg$parsename_char(): any {
    let s0;

    if (peg$c534.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c535); }
    }

    return s0;
  }

  function peg$parseunicode_char(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c536) {
      s1 = peg$c536;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c537); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      if (peg$c538.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c539); }
      }
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          if (peg$c538.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c539); }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c540(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename(): any {
    let s0;

    s0 = peg$parsename_quoted();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsename_unquoted();
    }

    return s0;
  }

  function peg$parsename_quoted(): any {
    let s0;

    s0 = peg$parsename_bracketed();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsename_backticked();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parsename_dblquoted();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parsename_sglquoted();
        }
      }
    }

    return s0;
  }

  function peg$parsename_unquoted(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$parsereserved_words();
    if (s2 as any === peg$FAILED) {
      s2 = peg$parsenumber_digit();
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunicode_char();
      if (s3 as any === peg$FAILED) {
        s3 = peg$parsename_char();
      }
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunicode_char();
          if (s3 as any === peg$FAILED) {
            s3 = peg$parsename_char();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c182(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename_reserved(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$currPos;
    peg$silentFails++;
    s2 = peg$parsereserved_critical_list();
    if (s2 as any === peg$FAILED) {
      s2 = peg$parsenumber_digit();
    }
    peg$silentFails--;
    if (s2 as any === peg$FAILED) {
      s1 = undefined;
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseunicode_char();
      if (s3 as any === peg$FAILED) {
        s3 = peg$parsename_char();
      }
      if (s3 as any !== peg$FAILED) {
        while (s3 as any !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseunicode_char();
          if (s3 as any === peg$FAILED) {
            s3 = peg$parsename_char();
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c541(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename_bracketed(): any {
    let s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsesym_bopen();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$currPos;
        s6 = peg$currPos;
        peg$silentFails++;
        s7 = peg$parsebracket_terminator();
        peg$silentFails--;
        if (s7 as any === peg$FAILED) {
          s6 = undefined;
        } else {
          peg$currPos = s6;
          s6 = peg$FAILED;
        }
        if (s6 as any !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s7 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c542); }
          }
          if (s7 as any !== peg$FAILED) {
            s6 = [s6, s7];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        } else {
          peg$currPos = s5;
          s5 = peg$FAILED;
        }
        while (s5 as any !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          s7 = peg$parsebracket_terminator();
          peg$silentFails--;
          if (s7 as any === peg$FAILED) {
            s6 = undefined;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 as any !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c542); }
            }
            if (s7 as any !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
        }
        if (s4 as any !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 as any !== peg$FAILED) {
          s4 = peg$parsebracket_terminator();
          if (s4 as any !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c543(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsebracket_terminator(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c544.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c545); }
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      if (peg$c544.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c545); }
      }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsesym_bclose();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parseo();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename_dblquoted(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c546;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c547); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c548) {
        s3 = peg$c548;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c549); }
      }
      if (s3 as any === peg$FAILED) {
        if (peg$c550.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c551); }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c548) {
          s3 = peg$c548;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c549); }
        }
        if (s3 as any === peg$FAILED) {
          if (peg$c550.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c551); }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 34) {
          s3 = peg$c546;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c547); }
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c552(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename_sglquoted(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c553;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c554); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c22) {
        s3 = peg$c22;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s3 as any === peg$FAILED) {
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s3 = peg$c22;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c23); }
        }
        if (s3 as any === peg$FAILED) {
          if (peg$c24.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c25); }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c553;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c554); }
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c555(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsename_backticked(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c556;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c557); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      if (input.substr(peg$currPos, 2) === peg$c558) {
        s3 = peg$c558;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c559); }
      }
      if (s3 as any === peg$FAILED) {
        if (peg$c560.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c561); }
        }
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        if (input.substr(peg$currPos, 2) === peg$c558) {
          s3 = peg$c558;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c559); }
        }
        if (s3 as any === peg$FAILED) {
          if (peg$c560.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c561); }
          }
        }
      }
      if (s2 as any !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 96) {
          s3 = peg$c556;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c557); }
        }
        if (s3 as any !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c562(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsesym_bopen(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      s1 = peg$c564;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c565); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c563); }
    }

    return s0;
  }

  function peg$parsesym_bclose(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 93) {
      s1 = peg$c567;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c568); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c566); }
    }

    return s0;
  }

  function peg$parsesym_popen(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 40) {
      s1 = peg$c570;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c571); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c569); }
    }

    return s0;
  }

  function peg$parsesym_pclose(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 41) {
      s1 = peg$c573;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c574); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c572); }
    }

    return s0;
  }

  function peg$parsesym_comma(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 44) {
      s1 = peg$c576;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c577); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c575); }
    }

    return s0;
  }

  function peg$parsesym_dot(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 46) {
      s1 = peg$c579;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c580); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c578); }
    }

    return s0;
  }

  function peg$parsesym_star(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 42) {
      s1 = peg$c582;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c583); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c581); }
    }

    return s0;
  }

  function peg$parsesym_quest(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 63) {
      s1 = peg$c585;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c586); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c584); }
    }

    return s0;
  }

  function peg$parsesym_sglquote(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c553;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c554); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c587); }
    }

    return s0;
  }

  function peg$parsesym_dblquote(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 34) {
      s1 = peg$c546;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c547); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c588); }
    }

    return s0;
  }

  function peg$parsesym_backtick(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 96) {
      s1 = peg$c556;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c557); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c589); }
    }

    return s0;
  }

  function peg$parsesym_tilde(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 126) {
      s1 = peg$c591;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c592); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c590); }
    }

    return s0;
  }

  function peg$parsesym_plus(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 43) {
      s1 = peg$c594;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c595); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c593); }
    }

    return s0;
  }

  function peg$parsesym_minus(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c597;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c598); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c596); }
    }

    return s0;
  }

  function peg$parsesym_equal(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      s1 = peg$c599;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c600); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c427); }
    }

    return s0;
  }

  function peg$parsesym_amp(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      s1 = peg$c602;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c603); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c601); }
    }

    return s0;
  }

  function peg$parsesym_pipe(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 124) {
      s1 = peg$c605;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c606); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c604); }
    }

    return s0;
  }

  function peg$parsesym_mod(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 37) {
      s1 = peg$c607;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c608); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c418); }
    }

    return s0;
  }

  function peg$parsesym_lt(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      s1 = peg$c609;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c610); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c423); }
    }

    return s0;
  }

  function peg$parsesym_gt(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 62) {
      s1 = peg$c611;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c612); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c424); }
    }

    return s0;
  }

  function peg$parsesym_excl(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      s1 = peg$c614;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c615); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c613); }
    }

    return s0;
  }

  function peg$parsesym_semi(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      s1 = peg$c617;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c618); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c616); }
    }

    return s0;
  }

  function peg$parsesym_colon(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      s1 = peg$c65;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c619); }
    }

    return s0;
  }

  function peg$parsesym_fslash(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c621;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c622); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c620); }
    }

    return s0;
  }

  function peg$parsesym_bslash(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 92) {
      s1 = peg$c624;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c625); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parseo();
      if (s2 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c2(s1);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c623); }
    }

    return s0;
  }

  function peg$parseABORT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c626) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c627); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseACTION(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c628) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c629); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseADD(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c630) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c631); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAFTER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c632) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c633); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseALL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c634) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c635); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseALTER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c636) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c637); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseANALYZE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c638) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c639); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAND(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c640) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c641); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAS(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c642) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c643); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseASC(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c644) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c645); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseATTACH(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c646) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c647); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseAUTOINCREMENT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 13).toLowerCase() === peg$c648) {
      s1 = input.substr(peg$currPos, 13);
      peg$currPos += 13;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c649); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseBEFORE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c650) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c651); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseBEGIN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c652) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c653); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseBETWEEN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c654) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c655); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseBY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c656) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c657); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCASCADE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c658) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c659); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCASE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c660) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c661); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCAST(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c662) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c663); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCHECK(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c664) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c665); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCOLLATE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c666) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c667); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCOLUMN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c668) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c669); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCOMMIT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c670) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c671); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCONFLICT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c672) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c673); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCONSTRAINT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c674) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c675); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCREATE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c676) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c677); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCROSS(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c678) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c679); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCURRENT_DATE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c680) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c681); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCURRENT_TIME(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 12).toLowerCase() === peg$c682) {
      s1 = input.substr(peg$currPos, 12);
      peg$currPos += 12;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c683); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseCURRENT_TIMESTAMP(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 17).toLowerCase() === peg$c684) {
      s1 = input.substr(peg$currPos, 17);
      peg$currPos += 17;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c685); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDATABASE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c686) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c687); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDEFAULT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c688) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c689); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDEFERRABLE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c690) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c691); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDEFERRED(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c692) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c693); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDELETE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c694) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c695); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDESC(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c696) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c697); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDETACH(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c698) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c699); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDISTINCT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c700) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c701); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseDROP(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c702) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c703); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEACH(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c704) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c705); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseELSE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c706) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c707); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEND(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c708) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c709); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseESCAPE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c710) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c711); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEXCEPT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c712) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c713); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEXCLUSIVE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c714) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c715); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEXISTS(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c716) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c717); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseEXPLAIN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c718) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c719); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFAIL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c720) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c721); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFOR(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c722) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c723); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFOREIGN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c724) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c725); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFROM(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c726) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c727); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseFULL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c728) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c729); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGLOB(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c730) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c731); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseGROUP(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c732) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c733); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseHAVING(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c734) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c735); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIF(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c736) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c737); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIGNORE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c738) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c739); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIMMEDIATE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c740) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c741); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c742) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c743); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINDEX(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c744) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c745); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINDEXED(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c746) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c747); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINITIALLY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c748) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c749); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINNER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c750) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c751); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINSERT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c752) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c753); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINSTEAD(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c754) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c755); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINTERSECT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c756) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c757); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseINTO(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c758) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c759); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseIS(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c760) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c761); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseISNULL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c762) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c763); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseJOIN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c764) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c765); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseKEY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c766) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c767); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLEFT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c768) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c769); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLIKE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c770) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c771); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseLIMIT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c772) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c773); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseMATCH(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c774) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c775); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNATURAL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c776) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c777); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNO(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c778) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c779); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNOT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c780) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c781); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNOTNULL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c782) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c783); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseNULL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c89) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c90); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOF(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c784) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c785); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOFFSET(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c786) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c787); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseON(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c788) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c789); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOR(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c790) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c791); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseORDER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c792) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c793); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseOUTER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c794) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c795); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePLAN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c796) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c797); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePRAGMA(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c798) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c799); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsePRIMARY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c800) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c801); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseQUERY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c802) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c803); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRAISE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c804) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c805); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRECURSIVE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c806) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c807); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseREFERENCES(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 10).toLowerCase() === peg$c808) {
      s1 = input.substr(peg$currPos, 10);
      peg$currPos += 10;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c809); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseREGEXP(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c810) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c811); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseREINDEX(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c812) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c813); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRELEASE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c814) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c815); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRENAME(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c816) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c817); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseREPLACE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c818) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c819); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRESTRICT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c820) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c821); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseRIGHT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c822) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c823); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseROLLBACK(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 8).toLowerCase() === peg$c824) {
      s1 = input.substr(peg$currPos, 8);
      peg$currPos += 8;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c825); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseROW(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c826) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c827); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseROWID(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c828) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c829); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSAVEPOINT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c830) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c831); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSELECT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c832) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c833); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseSET(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c834) {
      s1 = input.substr(peg$currPos, 3);
      peg$currPos += 3;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c835); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTABLE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c836) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c837); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTEMP(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c838) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c839); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTEMPORARY(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 9).toLowerCase() === peg$c840) {
      s1 = input.substr(peg$currPos, 9);
      peg$currPos += 9;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c841); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTHEN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c842) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c843); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTO(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2).toLowerCase() === peg$c844) {
      s1 = input.substr(peg$currPos, 2);
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c845); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTRANSACTION(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 11).toLowerCase() === peg$c846) {
      s1 = input.substr(peg$currPos, 11);
      peg$currPos += 11;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c847); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseTRIGGER(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c848) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c849); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseUNION(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c850) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c851); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseUNIQUE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c852) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c853); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseUPDATE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c854) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c855); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseUSING(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c856) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c857); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVACUUM(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c858) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c859); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVALUES(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 6).toLowerCase() === peg$c860) {
      s1 = input.substr(peg$currPos, 6);
      peg$currPos += 6;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c861); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVIEW(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c862) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c863); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseVIRTUAL(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c864) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c865); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWHEN(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c866) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c867); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWHERE(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c868) {
      s1 = input.substr(peg$currPos, 5);
      peg$currPos += 5;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c869); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWITH(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 4).toLowerCase() === peg$c870) {
      s1 = input.substr(peg$currPos, 4);
      peg$currPos += 4;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c871); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseWITHOUT(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c872) {
      s1 = input.substr(peg$currPos, 7);
      peg$currPos += 7;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c873); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parsename_char();
      peg$silentFails--;
      if (s3 as any === peg$FAILED) {
        s2 = undefined;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsereserved_words(): any {
    let s0, s1;

    s0 = peg$currPos;
    s1 = peg$parsereserved_word_list();
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c874(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsereserved_word_list(): any {
    let s0;

    s0 = peg$parseABORT();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseACTION();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseADD();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseAFTER();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseALL();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parseALTER();
              if (s0 as any === peg$FAILED) {
                s0 = peg$parseANALYZE();
                if (s0 as any === peg$FAILED) {
                  s0 = peg$parseAND();
                  if (s0 as any === peg$FAILED) {
                    s0 = peg$parseAS();
                    if (s0 as any === peg$FAILED) {
                      s0 = peg$parseASC();
                      if (s0 as any === peg$FAILED) {
                        s0 = peg$parseATTACH();
                        if (s0 as any === peg$FAILED) {
                          s0 = peg$parseAUTOINCREMENT();
                          if (s0 as any === peg$FAILED) {
                            s0 = peg$parseBEFORE();
                            if (s0 as any === peg$FAILED) {
                              s0 = peg$parseBEGIN();
                              if (s0 as any === peg$FAILED) {
                                s0 = peg$parseBETWEEN();
                                if (s0 as any === peg$FAILED) {
                                  s0 = peg$parseBY();
                                  if (s0 as any === peg$FAILED) {
                                    s0 = peg$parseCASCADE();
                                    if (s0 as any === peg$FAILED) {
                                      s0 = peg$parseCASE();
                                      if (s0 as any === peg$FAILED) {
                                        s0 = peg$parseCAST();
                                        if (s0 as any === peg$FAILED) {
                                          s0 = peg$parseCHECK();
                                          if (s0 as any === peg$FAILED) {
                                            s0 = peg$parseCOLLATE();
                                            if (s0 as any === peg$FAILED) {
                                              s0 = peg$parseCOLUMN();
                                              if (s0 as any === peg$FAILED) {
                                                s0 = peg$parseCOMMIT();
                                                if (s0 as any === peg$FAILED) {
                                                  s0 = peg$parseCONFLICT();
                                                  if (s0 as any === peg$FAILED) {
                                                    s0 = peg$parseCONSTRAINT();
                                                    if (s0 as any === peg$FAILED) {
                                                      s0 = peg$parseCREATE();
                                                      if (s0 as any === peg$FAILED) {
                                                        s0 = peg$parseCROSS();
                                                        if (s0 as any === peg$FAILED) {
                                                          s0 = peg$parseCURRENT_DATE();
                                                          if (s0 as any === peg$FAILED) {
                                                            s0 = peg$parseCURRENT_TIME();
                                                            if (s0 as any === peg$FAILED) {
                                                              s0 = peg$parseCURRENT_TIMESTAMP();
                                                              if (s0 as any === peg$FAILED) {
                                                                s0 = peg$parseDATABASE();
                                                                if (s0 as any === peg$FAILED) {
                                                                  s0 = peg$parseDEFAULT();
                                                                  if (s0 as any === peg$FAILED) {
                                                                    s0 = peg$parseDEFERRABLE();
                                                                    if (s0 as any === peg$FAILED) {
                                                                      s0 = peg$parseDEFERRED();
                                                                      if (s0 as any === peg$FAILED) {
                                                                        s0 = peg$parseDELETE();
                                                                        if (s0 as any === peg$FAILED) {
                                                                          s0 = peg$parseDESC();
                                                                          if (s0 as any === peg$FAILED) {
                                                                            s0 = peg$parseDETACH();
                                                                            if (s0 as any === peg$FAILED) {
                                                                              s0 = peg$parseDISTINCT();
                                                                              if (s0 as any === peg$FAILED) {
                                                                                s0 = peg$parseDROP();
                                                                                if (s0 as any === peg$FAILED) {
                                                                                  s0 = peg$parseEACH();
                                                                                  if (s0 as any === peg$FAILED) {
                                                                                    s0 = peg$parseELSE();
                                                                                    if (s0 as any === peg$FAILED) {
                                                                                      s0 = peg$parseEND();
                                                                                      if (s0 as any === peg$FAILED) {
                                                                                        s0 = peg$parseESCAPE();
                                                                                        if (s0 as any === peg$FAILED) {
                                                                                          s0 = peg$parseEXCEPT();
                                                                                          if (s0 as any === peg$FAILED) {
                                                                                            s0 = peg$parseEXCLUSIVE();
                                                                                            if (s0 as any === peg$FAILED) {
                                                                                              s0 = peg$parseEXISTS();
                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                s0 = peg$parseEXPLAIN();
                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                  s0 = peg$parseFAIL();
                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                    s0 = peg$parseFOR();
                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                      s0 = peg$parseFOREIGN();
                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                        s0 = peg$parseFROM();
                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                          s0 = peg$parseFULL();
                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                            s0 = peg$parseGLOB();
                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                              s0 = peg$parseGROUP();
                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                s0 = peg$parseHAVING();
                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                  s0 = peg$parseIF();
                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                    s0 = peg$parseIGNORE();
                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                      s0 = peg$parseIMMEDIATE();
                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                        s0 = peg$parseIN();
                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                          s0 = peg$parseINDEX();
                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                            s0 = peg$parseINDEXED();
                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                              s0 = peg$parseINITIALLY();
                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                s0 = peg$parseINNER();
                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                  s0 = peg$parseINSERT();
                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                    s0 = peg$parseINSTEAD();
                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                      s0 = peg$parseINTERSECT();
                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                        s0 = peg$parseINTO();
                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                          s0 = peg$parseIS();
                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                            s0 = peg$parseISNULL();
                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                              s0 = peg$parseJOIN();
                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                s0 = peg$parseKEY();
                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                  s0 = peg$parseLEFT();
                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                    s0 = peg$parseLIKE();
                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                      s0 = peg$parseLIMIT();
                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                        s0 = peg$parseMATCH();
                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                          s0 = peg$parseNATURAL();
                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                            s0 = peg$parseNO();
                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                              s0 = peg$parseNOT();
                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                s0 = peg$parseNOTNULL();
                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                  s0 = peg$parseNULL();
                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                    s0 = peg$parseOF();
                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                      s0 = peg$parseOFFSET();
                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                        s0 = peg$parseON();
                                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                                          s0 = peg$parseOR();
                                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                                            s0 = peg$parseORDER();
                                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                                              s0 = peg$parseOUTER();
                                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                                s0 = peg$parsePLAN();
                                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                                  s0 = peg$parsePRAGMA();
                                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                                    s0 = peg$parsePRIMARY();
                                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                                      s0 = peg$parseQUERY();
                                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                                        s0 = peg$parseRAISE();
                                                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                                                          s0 = peg$parseRECURSIVE();
                                                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                                                            s0 = peg$parseREFERENCES();
                                                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                                                              s0 = peg$parseREGEXP();
                                                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                s0 = peg$parseREINDEX();
                                                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                  s0 = peg$parseRELEASE();
                                                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                    s0 = peg$parseRENAME();
                                                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                      s0 = peg$parseREPLACE();
                                                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                        s0 = peg$parseRESTRICT();
                                                                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                          s0 = peg$parseRIGHT();
                                                                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                            s0 = peg$parseROLLBACK();
                                                                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                              s0 = peg$parseROW();
                                                                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                s0 = peg$parseSAVEPOINT();
                                                                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                  s0 = peg$parseSELECT();
                                                                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                    s0 = peg$parseSET();
                                                                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                      s0 = peg$parseTABLE();
                                                                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                        s0 = peg$parseTEMPORARY();
                                                                                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                          s0 = peg$parseTHEN();
                                                                                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                            s0 = peg$parseTO();
                                                                                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                              s0 = peg$parseTRANSACTION();
                                                                                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                s0 = peg$parseTRIGGER();
                                                                                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                  s0 = peg$parseUNION();
                                                                                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                    s0 = peg$parseUNIQUE();
                                                                                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                      s0 = peg$parseUPDATE();
                                                                                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                        s0 = peg$parseUSING();
                                                                                                                                                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                          s0 = peg$parseVACUUM();
                                                                                                                                                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                            s0 = peg$parseVALUES();
                                                                                                                                                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                              s0 = peg$parseVIEW();
                                                                                                                                                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                                s0 = peg$parseVIRTUAL();
                                                                                                                                                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                                  s0 = peg$parseWHEN();
                                                                                                                                                                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                                    s0 = peg$parseWHERE();
                                                                                                                                                                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                                      s0 = peg$parseWITH();
                                                                                                                                                                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                                                                                                                                                                        s0 = peg$parseWITHOUT();
                                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                  }
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        }
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  }
                                                                                                                                                                                                }
                                                                                                                                                                                              }
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    }
                                                                                                                                                                                  }
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsereserved_critical_list(): any {
    let s0;

    s0 = peg$parseADD();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parseALL();
      if (s0 as any === peg$FAILED) {
        s0 = peg$parseALTER();
        if (s0 as any === peg$FAILED) {
          s0 = peg$parseAND();
          if (s0 as any === peg$FAILED) {
            s0 = peg$parseAS();
            if (s0 as any === peg$FAILED) {
              s0 = peg$parseAUTOINCREMENT();
              if (s0 as any === peg$FAILED) {
                s0 = peg$parseBETWEEN();
                if (s0 as any === peg$FAILED) {
                  s0 = peg$parseCASE();
                  if (s0 as any === peg$FAILED) {
                    s0 = peg$parseCHECK();
                    if (s0 as any === peg$FAILED) {
                      s0 = peg$parseCOLLATE();
                      if (s0 as any === peg$FAILED) {
                        s0 = peg$parseCOMMIT();
                        if (s0 as any === peg$FAILED) {
                          s0 = peg$parseCONSTRAINT();
                          if (s0 as any === peg$FAILED) {
                            s0 = peg$parseCREATE();
                            if (s0 as any === peg$FAILED) {
                              s0 = peg$parseDEFAULT();
                              if (s0 as any === peg$FAILED) {
                                s0 = peg$parseDEFERRABLE();
                                if (s0 as any === peg$FAILED) {
                                  s0 = peg$parseDELETE();
                                  if (s0 as any === peg$FAILED) {
                                    s0 = peg$parseDISTINCT();
                                    if (s0 as any === peg$FAILED) {
                                      s0 = peg$parseDROP();
                                      if (s0 as any === peg$FAILED) {
                                        s0 = peg$parseELSE();
                                        if (s0 as any === peg$FAILED) {
                                          s0 = peg$parseESCAPE();
                                          if (s0 as any === peg$FAILED) {
                                            s0 = peg$parseEXCEPT();
                                            if (s0 as any === peg$FAILED) {
                                              s0 = peg$parseEXISTS();
                                              if (s0 as any === peg$FAILED) {
                                                s0 = peg$parseFOREIGN();
                                                if (s0 as any === peg$FAILED) {
                                                  s0 = peg$parseFROM();
                                                  if (s0 as any === peg$FAILED) {
                                                    s0 = peg$parseGROUP();
                                                    if (s0 as any === peg$FAILED) {
                                                      s0 = peg$parseHAVING();
                                                      if (s0 as any === peg$FAILED) {
                                                        s0 = peg$parseIN();
                                                        if (s0 as any === peg$FAILED) {
                                                          s0 = peg$parseINDEX();
                                                          if (s0 as any === peg$FAILED) {
                                                            s0 = peg$parseINSERT();
                                                            if (s0 as any === peg$FAILED) {
                                                              s0 = peg$parseINTERSECT();
                                                              if (s0 as any === peg$FAILED) {
                                                                s0 = peg$parseINTO();
                                                                if (s0 as any === peg$FAILED) {
                                                                  s0 = peg$parseIS();
                                                                  if (s0 as any === peg$FAILED) {
                                                                    s0 = peg$parseISNULL();
                                                                    if (s0 as any === peg$FAILED) {
                                                                      s0 = peg$parseJOIN();
                                                                      if (s0 as any === peg$FAILED) {
                                                                        s0 = peg$parseLIMIT();
                                                                        if (s0 as any === peg$FAILED) {
                                                                          s0 = peg$parseNOT();
                                                                          if (s0 as any === peg$FAILED) {
                                                                            s0 = peg$parseNOTNULL();
                                                                            if (s0 as any === peg$FAILED) {
                                                                              s0 = peg$parseNULL();
                                                                              if (s0 as any === peg$FAILED) {
                                                                                s0 = peg$parseON();
                                                                                if (s0 as any === peg$FAILED) {
                                                                                  s0 = peg$parseOR();
                                                                                  if (s0 as any === peg$FAILED) {
                                                                                    s0 = peg$parseORDER();
                                                                                    if (s0 as any === peg$FAILED) {
                                                                                      s0 = peg$parsePRIMARY();
                                                                                      if (s0 as any === peg$FAILED) {
                                                                                        s0 = peg$parseREFERENCES();
                                                                                        if (s0 as any === peg$FAILED) {
                                                                                          s0 = peg$parseSELECT();
                                                                                          if (s0 as any === peg$FAILED) {
                                                                                            s0 = peg$parseSET();
                                                                                            if (s0 as any === peg$FAILED) {
                                                                                              s0 = peg$parseTABLE();
                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                s0 = peg$parseTHEN();
                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                  s0 = peg$parseTO();
                                                                                                  if (s0 as any === peg$FAILED) {
                                                                                                    s0 = peg$parseTRANSACTION();
                                                                                                    if (s0 as any === peg$FAILED) {
                                                                                                      s0 = peg$parseUNION();
                                                                                                      if (s0 as any === peg$FAILED) {
                                                                                                        s0 = peg$parseUNIQUE();
                                                                                                        if (s0 as any === peg$FAILED) {
                                                                                                          s0 = peg$parseUPDATE();
                                                                                                          if (s0 as any === peg$FAILED) {
                                                                                                            s0 = peg$parseUSING();
                                                                                                            if (s0 as any === peg$FAILED) {
                                                                                                              s0 = peg$parseVALUES();
                                                                                                              if (s0 as any === peg$FAILED) {
                                                                                                                s0 = peg$parseWHEN();
                                                                                                                if (s0 as any === peg$FAILED) {
                                                                                                                  s0 = peg$parseWHERE();
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsecomment(): any {
    let s0, s1;

    s0 = peg$parsecomment_line();
    if (s0 as any === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parsecomment_block();
      if (s1 as any !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c875();
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsecomment_line(): any {
    let s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c877) {
      s1 = peg$c877;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c878); }
    }
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (peg$c879.test(input.charAt(peg$currPos))) {
        s5 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c880); }
      }
      peg$silentFails--;
      if (s5 as any === peg$FAILED) {
        s4 = undefined;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 as any !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c542); }
        }
        if (s5 as any !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$c879.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c880); }
        }
        peg$silentFails--;
        if (s5 as any === peg$FAILED) {
          s4 = undefined;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 as any !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c542); }
          }
          if (s5 as any !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c876); }
    }

    return s0;
  }

  function peg$parsecomment_block(): any {
    let s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parsecomment_block_start();
    if (s1 as any !== peg$FAILED) {
      s2 = peg$parsecomment_block_feed();
      if (s2 as any !== peg$FAILED) {
        s3 = peg$parsecomment_block_end();
        if (s3 as any !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c881); }
    }

    return s0;
  }

  function peg$parsecomment_block_start(): any {
    let s0;

    if (input.substr(peg$currPos, 2) === peg$c882) {
      s0 = peg$c882;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c883); }
    }

    return s0;
  }

  function peg$parsecomment_block_end(): any {
    let s0;

    if (input.substr(peg$currPos, 2) === peg$c884) {
      s0 = peg$c884;
      peg$currPos += 2;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c885); }
    }

    return s0;
  }

  function peg$parsecomment_block_body(): any {
    let s0, s1, s2, s3;

    s0 = [];
    s1 = peg$currPos;
    s2 = peg$currPos;
    peg$silentFails++;
    s3 = peg$parsecomment_block_end();
    if (s3 as any === peg$FAILED) {
      s3 = peg$parsecomment_block_start();
    }
    peg$silentFails--;
    if (s3 as any === peg$FAILED) {
      s2 = undefined;
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 as any !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c542); }
      }
      if (s3 as any !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 as any !== peg$FAILED) {
      while (s1 as any !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parsecomment_block_end();
        if (s3 as any === peg$FAILED) {
          s3 = peg$parsecomment_block_start();
        }
        peg$silentFails--;
        if (s3 as any === peg$FAILED) {
          s2 = undefined;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 as any !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c542); }
          }
          if (s3 as any !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }
    } else {
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseblock_body_nodes(): any {
    let s0;

    s0 = peg$parsecomment_block_body();
    if (s0 as any === peg$FAILED) {
      s0 = peg$parsecomment_block();
    }

    return s0;
  }

  function peg$parsecomment_block_feed(): any {
    let s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseblock_body_nodes();
    if (s1 as any !== peg$FAILED) {
      s2 = [];
      if (peg$c886.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c887); }
      }
      if (s3 as any === peg$FAILED) {
        s3 = peg$parseblock_body_nodes();
      }
      while (s3 as any !== peg$FAILED) {
        s2.push(s3);
        if (peg$c886.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c887); }
        }
        if (s3 as any === peg$FAILED) {
          s3 = peg$parseblock_body_nodes();
        }
      }
      if (s2 as any !== peg$FAILED) {
        s1 = [s1, s2];
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseo(): any {
    let s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c886.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c887); }
    }
    if (s2 as any === peg$FAILED) {
      s2 = peg$parsecomment();
    }
    while (s2 as any !== peg$FAILED) {
      s1.push(s2);
      if (peg$c886.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c887); }
      }
      if (s2 as any === peg$FAILED) {
        s2 = peg$parsecomment();
      }
    }
    if (s1 as any !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c13(s1);
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 as any === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c888); }
    }

    return s0;
  }

  function peg$parse_TODO_(): any {
    let s0;

    if (input.substr(peg$currPos, 8) === peg$c889) {
      s0 = peg$c889;
      peg$currPos += 8;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c890); }
    }

    return s0;
  }


    function makeArray(arr) {
      if (!isOkay(arr)) {
        return [];
      }
      return !Array.isArray(arr) ? [arr] : arr;
    }

    function isOkay(obj) {
      return obj != null;
    }

    function foldString(parts, glue = ' ') {
      const folded = parts
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => {
        return `${prev}${nodeToString(cur)}${glue}`;
      }, '');
      return folded.trim();
    }

    function foldStringWord(parts) {
      return foldString(parts, '');
    }

    function foldStringKey(parts) {
      return foldString(parts).toLowerCase();
    }

    function flattenAll(arr) {
      return arr
      .filter((part) => isOkay(part))
      .reduce((prev, cur) => prev.concat(cur), []);
    }

    function unescape(str, quoteChar = '\'') {
      const re = new RegExp(`${quoteChar}{2}`, 'g');
      return nodeToString(str).replace(re, quoteChar);
    }

    function nodeToString(node = []) {
      return makeArray(node).join('');
    }

    /*
     * A text node has
     * - no leading or trailing whitespace
     */
    function textNode(node) {
      return nodeToString(node).trim();
    }

    function keyNode(node) {
      return textNode(node).toLowerCase();
    }

    function isArrayOkay(arr) {
      return Array.isArray(arr) && arr.length > 0 && isOkay(arr[0]);
    }

    function composeBinary(first, rest) {
      return rest
      .reduce((left, [ x, operation, y, right ]) => {
        return {
          'type': 'expression',
          'format': 'binary',
          'variant': 'operation',
          'operation': keyNode(operation),
          'left': left,
          'right': right
        };
      }, first);
    }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

export interface ParseOptions {
  filename?: string;
  startRule?: string;
  tracer?: any;
  [key: string]: any;
}
export type ParseFunction = (input: string, options?: ParseOptions) => any;
export const parse: ParseFunction = peg$parse;

